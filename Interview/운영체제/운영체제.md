# 1. 시스템 콜이 무엇인지 설명해 주세요

유저 레벨 프로그램이 운영체제 커널에게 서비스나 기능을 요청할 수 있도록 하는 프로세스의 인터페이스

- 운영체제는 시스템 호출을 통한 인터페이스를 제공해서, 사용자 프로그램이 하드웨어나 다른 시스템 리소스와 상호작용할 수 있게 해준다.
- 시스템 호출은 애플리케이션이 low-level 작업(메모리 할당이나 프로세스 관리) 등을 수행하거나 권한이 필요한 작업을 수행하는 것을 가능하게 하는 중요한 역할을 한다.

### 1) 우리가 사용하는 시스템 콜의 예시를 들어주세요.

**파일 관련 시스템 콜**

- open()
    - 파일을 열기 위한 시스템 콜
- read(), write()
    - 파일로 부터 읽거나 파일에 쓰기 위한 시스템 콜
- close()
    - 파일을 닫기 위한 시스템 콜

**프로세스 관련 시스템 콜**

- fork()
    - 새로운 프로세스를 생성하는 시스템 콜
- exec()
    - 새로운 프로그램을 실행하는 시스템 콜
- exit()
    - 프로세스를 종료하는 시스템 콜

### 2) 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.

1. 사용자 프로그램이 시스템 콜 호출
    1. 사용자 프로그램이 시스템 콜을 호출하여 서비스를 요청한다. 이 요청을 보통 언어나 라이브러리에서 제공하는 시스템 콜 인터페이스를 통해 이루어진다.
2. 커널 모드 전환
    1. 시스템 콜을 호출하면 CPU는 커널 모드로 전환된다.
    2. 사용자 모드와 커널 모드는 프로세스가 CPU와 다른 시스템 리소스에 접근하는 권한 수준을 나타낸다.
    3. 일반적으로 사용자 프로그램은 사용자 모드에서 실행되며, 커널은 커널 모드에서 실행된다.
3. 시스템 콜 처리
    1. 커널이 사용자 프로그램의 요청을 받으면, 해당 시스템 콜을 처리하기 위해 적절한 커널 함수를 호출한다.
    2. 이 함수는 요청된 작업을 수행하고 결과를 반환
4. 결과 반환
    1. 시스템 콜이 완료되면, 커널은 결과를 사용자 프로그램에 반환한다.
5. 커널 모드 → 사용자 모드로 복귀
    1. 시스템 콜 처리가 완료되면, CPU는 다시 사용자 모드로 전환된다.
    2. 이후 사용자 프로그램은 시스템 콜 호출 이후의 코드를 계속 실행한다.

### 3) 시스템 콜의 유형에 대해 설명해주세요.

- 프로세스 제어
    - 프로세스 생성/종료/일시정지, 재개 등의 작업을 수행한다.
- 파일 관리
    - 파일 생성/열기/읽기/쓰기/닫기 등의 파일 작업을 수행한다.
    - 파일 및 디렉토리의 권한 설정 및 관리를 제공한다.
- 장치 관리
    - 장치 제어: 입출력 장치 (디스크,네트워크 인터페이스,프린터 등)를 관리한다.
- 정보 관리
    - 시스템 정보 : 시간,날짜,시스템 상태등의 정보를 제공한다.
    - 시스템 자원 : 메모리,CPU 사용량등의 자원을 관리 한다.
- 통신 관리
    - 프로세스 간 통신 : 프로세스 간 데이터 전송, 동기화 등을 지원한다.
    - 네트워크 통신 : 네트워크 상에서의 데이터 전송 및 통신 프로토콜을 관리한다.
- 보안 관리
    - 사용자 인증 및 권한 관리 : 사용자 인증,권한 부여, 암호화 등을 지원한다.

### 4) 운영체제의 Dual Mode 에 대해 설명해 주세요.

운영체제의 듀얼 모드는 컴퓨터 시스템의 보안과 안정승을 유지하기 위한 기능이다. 듀얼 모드는 사용자 모드와 커널 모드로 구성된다.

- 사용자 모드
    - 사용자 프로그램이 실행되는 모드
    - 사용자 모드에서는 제한된 시스템 리소스에만 접근할 수 있다.
        - 일반적으로는 사용자가 작성한 응용 프로그램이 이 모드에서 실행된다.
    - 사용자 프로그램은 시스템 콜을 통해 운영체제의 기능을 사용할 수 있다. 하지만 시스템 콜을 통해서만 운영 체제의 기능에 접근할 수 있다.
- 커널 모드
    - 운영 체제의 핵심 부분인 커널이 실행되는 모드
    - 커널 모드에서는 시스템의 모든 리소스에 접근할 수 있다.
        - 이는 프로세스 제어, 메모리 관리, 장치 관리 등의 작업이 가능
    - 특권 명령어를 실행할 수 있는 권한을 가지고 있다.
        - 이러한 명령어는 시스템의 안정성을 유지하기 위해 보안 검사를 거쳐야한다.

### **5) 왜 듀얼 모드로 각 모드가 구분되어 있을까요 ?**

운영체제가 안정적으로 동작하고 보안을 유지하기 위한 중요한 요소

- **보안 강화**: 커널 모드에서는 시스템의 핵심 부분이 실행되므로, 악의적인 사용자가 시스템 리소스에 직접 접근하는 것을 방지합니다.
- **안정성 확보**: 사용자 프로그램의 오류나 잘못된 동작으로 인해 시스템이 손상되는 것을 방지하기 위해, 커널 모드에서만 특정 작업을 실행할 수 있도록 제한합니다.

### 6) 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요

- System call의 고유한 식별자로 구분합니다.
- 유저 프로그램이 system call을 날리면, 커널에게 이 식별자를 제공하고 커널은 이 식별자를 이용해서 어떤 작업을 요청했는지 알 수 있습니다.

# 2. 인터럽트란?

- 컴퓨터 시스템에서 발생하는 이벤트로, CPU가 현재 실행중인 작업을 일시적으로 중단하고 미리 정의된 처리기능을 수행하는 메커니즘
- 인터럽트는 외부 또는 내부적인 사건에 의해 발생할 수 있으며, 주로 하드웨어나 소프트웨어에서 발생한다.

### 1) 인터럽트는 어떻게 처리?

1. 인터럽트 발생
    1. 하드웨어 또는 소프트웨어 이벤트가 발생하여 CPU에게 인터럽트 요청
    2. 하드웨어: 외부 장치에서 데이터 도착 혹은 타이머 만료 등 인터럽트 발생
    3. 소프트웨어: 잘못된 명령어 실행 또는 나누기 오류 같은 예외 상황이 발생하면 소프트웨어 인터럽트 발생
2. 인터럽트 처리 요청
    1. 인터럽트가 발생하면 CPU는 현재 실행중인 작업을 일시 중단하고 해당 인터럽트에 대한 처리를 요청한다.
    2. 이를 위해 인터럽트 핸들러 또는 인터럽트 서비스 루틴이라고 불리는 특수한 코드가 실행된다.
3. 인터럽트 서비스 루틴 실행
    1. CPU는 해당 인터럽트에 대한 ISR을 실행.
    2. ISR은 인터럽트의 원인을 파악하고, 적절한 처리를 수행한다.
4. 인터럽트 처리
    1. ISR은 인터럽트가 발생한 원인에 따라 다양한 작업을 수행
    2. 예를들어 하드웨어의 경우 데이터를 수신하여 메모리에 저장
    3. 예를들어 소프트웨어 경우 예외상황을 처리하거나 불필요한 서비스를 운영 체제에 요청할 수 있다.
5. 인터럽트 처리 완료
    1. ISR이 인터럽트 처리를 완료하면 CPU는 원래 실행되던 작업으로 복휘하여 계속 진행한다.

### 3) 폴링 방식?

- 조건이 변경되었는지 또는 추가 작업을 위해 리소스가 준빋뵈었는지 여부를 반복적으로 쿼리하거나 확인하는 것을 의미한다.
- Polling 방식을 인터럽트 체크에 사용하게 된다면, 특정 시간 간격에 인터럽트 여부를 매시간 확인하고 모니터링 하게 될 것입니다.
- 비교적 구현이 간단할 수 있지만, 주기적으로 확인을 해야해서 리소스 낭비의 요인이 될 수 있다.

### 4) HW / SW 인터럽트에 대해 설명해 주세요.

1. **하드웨어 인터럽트(Hardware Interrupt)**:
    - 하드웨어 인터럽트는 외부에서 발생하는 이벤트로, CPU에게 어떤 장치로부터의 요청이나 상태 변화를 알리는 역할을 합니다.
    - 주로 외부 장치에서의 이벤트(예: 데이터 도착, 타이머 만료)가 발생할 때 사용됩니다.
    - 하드웨어 인터럽트는 하드웨어적인 원인에 의해 발생하므로, 시스템의 하드웨어 레벨에서 처리됩니다.
2. **소프트웨어 인터럽트(Software Interrupt)**:
    - 소프트웨어 인터럽트는 프로그램 실행 중에 명령어나 예외 상황에 의해 발생하는 인터럽트입니다.
    - 주로 프로세스 내부에서의 예외 상황(예: 잘못된 명령어 실행, 나누기 오류)이나 운영 체제의 서비스 요청(예: 시스템 콜)에 사용됩니다.
    - 소프트웨어 인터럽트는 프로그램이나 운영 체제에서 명시적으로 호출하여 사용되므로, 소프트웨어적인 원인에 의해 발생합니다.

하드웨어 인터럽트와 소프트웨어 인터럽트는 모두 CPU가 현재 실행 중인 작업을 일시 중단하고 인터럽트 서비스 루틴을 실행하여 해당 인터럽트를 처리합니다. 하드웨어 인터럽트는 주로 하드웨어 레벨에서 발생하고 처리되며, 소프트웨어 인터럽트는 주로 소프트웨어 레벨에서 발생하고 처리됩니다.

### 4-1) 하드웨어 인터럽트와 소프트웨어 인터럽트 간의 우선순위는 어떻게 결정되나요?

- 하드웨어 인터럽트와 소프트웨어 인터럽트 간의 우선순위는 일반적으로 하드웨어 인터럽트가 더 높은 우선순위를 갖습니다.
    - 이는 하드웨어 인터럽트가 외부 장치와의 상호 작용이나 시스템의 기본 기능을 담당하기 때문에 중요성이 높기 때문입니다.
- 하드웨어 인터럽트는 CPU의 외부에서 발생하며, 장치의 상태 변화나 외부 이벤트를 처리하기 위한 것입니다.
    - 이러한 이벤트들은 종종 실시간성을 요구하며, 따라서 하드웨어 인터럽트는 빠르게 처리되어야 합니다.
    - 따라서 하드웨어 인터럽트는 더 높은 우선순위를 갖게 됩니다.
- 반면 소프트웨어 인터럽트는 프로그램 내부에서 발생하며, 주로 예외 상황이나 운영 체제의 서비스 요청을 처리하기 위한 것입니다.
    - 하드웨어 인터럽트보다는 일반적으로 낮은 우선순위를 갖게 되며, 우선적으로 처리되어야 할 하드웨어 인터럽트가 없는 경우에만 소프트웨어 인터럽트가 처리됩니다.

우선순위가 높은 하드웨어 인터럽트가 먼저 처리되고, 그 후에 우선순위가 낮은 소프트웨어 인터럽트가 처리됩니다. 이렇게 함으로써 시스템은 빠르고 신속하게 외부 장치와의 상호 작용을 처리하면서도 소프트웨어적인 작업을 충분히 수행할 수 있습니다.

### 5) 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?

- 동시에 두 개 이상의 인터럽트가 발생하는 경우에는 각 인터럽트의 우선순위에 따라 처리됩니다.
- 주로 하드웨어 인터럽트와 소프트웨어 인터럽트는 서로 다른 우선순위를 갖기 때문에, 먼저 발생한 인터럽트부터 처리되고 다음으로 발생한 인터럽트가 처리됩니다.

# 3. 프로세스란 무엇인가?

- 프로세스는 컴퓨터에서 실행 중인 프로그램의 인스턴스를 나타낸다.
- 프로세스는 컴퓨터에서 실행중인 작업의 단위이다.
- 각 프로세스는 메모리에 할당되어 실행되며, CPU의 시간과 다른 시스템 리소스를 사용하여 작업을 수행한다.

### 1) 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.

- 프로그램
    - 실행 가능한 파일이며, 컴퓨터에서 작업을 수행하기 위해 설계된 명령어들의 집합이다.
- 프로세스
    - 운영체제로부터 자원을 할당받은 **작업의 단위**
    - 각 프로세스는 독립적인 메모리 공간을 가지며, OS에 의해 관리된다.
    - 여러 프로세스가 동시에 실행될 수 있으며, 각각은 서로 독릭접으로 실행된다.
- 스레드
    - 프로세스 내에서 실행되는 작업의 단위
        - 프로세스가 할당받은 자원을 이용하는 **실행 흐름의 단위**
    - 각 스레드는 프로세스의 자원을 공유하며, 동시에 여러 작업을 수행가능
    - 스레드는 프로세스의 주소 공간과 자원을 공유하기 때문에, 스레드간 통신이 비교적 간단하고 빠르다.
    - 프로세스는 보통 하나 이상의 스레드를 가지고 있으며, 다중 스레드 프로그래밍을 통해 병렬적 처리와 동시성을 구현할 수 있다.

간단히 말해, 프로그램은 실행 가능한 파일이고, 프로세스는 실행 중인 프로그램의 인스턴스이며, 스레드는 프로세스 내에서 실행되는 작업의 단위입니다.

### 1-1) 멀티 프로세싱 vs 멀티 태스킹

- 멀티 프로세싱
    - 여러개의 CPU 코어가 동시에 작업을 처리하는 것
- 멀티 태스킹
    - 단일 CPU에서 여러개의 작업을 동시에 처리하는 것을 의미

### 2) PCB가 무엇인가요

- PCB는 프로세스 제어 블록의 약자이다.
- PCB는 운영체제가 각 프로세스를 관리하기 위해 유지하는 데이터 구조
- 각 프로세스마다 하나의 PCB가 있으며, 이 PCB는 해당 프로세스의 상태 및 실행에 필요한 정보를 저장한다.
- CPU의 자원은 한정되어 있다.
    - 그래서 프로세스들은 돌아가며 한정된 시간만큼만 CPU를 이용한다.

PCB는 프로세스가 생성될 때 만들어지고, 프로세스가 종료될 때 소멸됩니다. 운영 체제는 PCB를 사용하여 프로세스의 상태를 추적하고, 프로세스 간의 스케줄링 및 리소스 할당을 관리합니다.

### 2-1) PCB에 담기는 정보들이 뭐가 있나요?

- 프로세스 ID = PID
    - 특정 프로세스를 식별하기 위해 부여하는 고유의 번호
- 레지스터 값
    - CPU 레지스터의 내용을 저장한다. 이는 프로세스가 다시 실행될 때 상태를 복원하는데 사용된다.
- 프로세스 상태 정보
    - 프로세스가 현재 실행중, 대기중 ,준비중 등의 상태를 나타내는 정보이다.
- CPU 스케줄링 정보
    - 프로세스가 언제, 어떤 순서로 CPU를 할당 받을지에 대한 정보
- 메모리 정보
    - 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
- 입출력 상태 정보
    - 프로세스가 사용하는 입출력 장치와 관련된 정보를 저장한다.

### 3) 그렇다면 스레는 PCB를 가지고 있을까요?

- 스레드는 자체적으로 PCB를 갖고 있지 않습니다.
- 프로세스 내에서 실행되는 모든 스레드는 **하나의 PCB**를 공유합니다.

**스레드는 PCB에 다음과 같은 정보를 저장합니다:**

- 스레드 식별자 (TID)
- 스레드 상태 (실행, 대기, 종료 등)
- 스레드 스택
- 레지스터 값

**스레드가 PCB를 공유하는 이유:**

- 메모리 및 CPU 리소스 절약
- 프로세스 내 스레드 간 빠른 통신
- 일관된 프로세스 환경 유지

### 4) 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?

**프로세스 생성**

- 새로운 프로세스를 생성하려면 fork() 시스템 콜을 사용한다.
    - 이는 부모 프로세스의 정확한 복사본을 만들어 자식 프로세스를 생성
    - 자식 프로세스는 부모 프로세스의 주소 공간, 파일 디스크립터, 다른 리소스를 상속
    - 주소 공간만 복사할 뿐, 메모리 공간은 공유하지 않고, 두 프로세스는 같은 프로세스 그룹에 속한다
- exec() 시스템 콜은 프로세스의 이미지를 새로운 프로그램으로 대체할 때 사용된다.
    - 따라서 fork() 후에 exec()를 호출하여 새로운 프로그램을 실행할 수 있다.

**스레드 생성**

- 스레드를 생성하려면 POSIX 스레드 라이브러리를 사용한다.
- pthread_create() 함수를 호출하여 새로운 스레드를 생성한다.
- 이 함수는 새로운 스레드의 핸들을 반환하고, 실행할 함수 및 해당 인수를 지정
- 새로운 스레드는 프로세스의 주소 공간을 공유하며, 동시에 여러 스레드가 같은 코드 및 자원에 접근할 수 있다.

스레드는 같은 프로세스 내에서 생성되며, 동일한 주소 공간 및 기타 리소스를 공유합니다. 이로써 스레드는 경량화되고 빠르게 생성될 수 있으며, 프로세스 간 통신 및 동기화 작업도 더욱 효율적으로 수행됩니다.

### 5) 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?

1. **자식 프로세스가 상태를 알리지 않고 죽는 경우**
- 운영체제는 해당 자식 프로세스를 좀비 프로세스로 표시한다.
    - 좀비 프로세스는 프로세스의 테이블에 여전히 남아있지만, 종료된 자식 프로세스의 정보를 유지한다.
- 부모 프로세스가 wait() 또는 waitpid() 함수를 사용하여 자식 프로세스의 종료 상태를 검사하지 않으면, 좀비 프로세스는 프로세스 테이블에 계속 남아있다.
1. **부모 프로세스가 먼저 죽을때** 
- 부모 프로세스가 종료되면, 운영 체제는 부모 프로세스의 자식 프로세스들을 고아 프로세스로 변경한다.
    - 이는 예전에 부모로부터 자신 프로세스의 관리가 끊어진 상태를 의미한다.
- 고아 프로세스들은 운영체제의 init 프로세스가 책임지고 관리한다.
    - init프로세스는 이러한 고아 프로세스들을 수집하고 종료할 책임이 있다.

따라서, 자식 프로세스의 상태를 정리하고 리소스를 해제하려면 부모 프로세스가 적절한 시점에 자식 프로세스의 종료 상태를 검사해야 합니다. 또한 부모 프로세스가 종료될 때에는 고아 프로세스가 되지 않도록 적절한 종료 절차를 수행해야 합니다.

### 5) 리눅스에서, 데몬 프로세스에 대해 설명해주세요.

**데몬 프로세스**는 사용자와 직접 상호작용하지 않고 백그라운드에서 실행되는 프로세스입니다. 일반적으로 시스템 부팅 시 자동으로 시작되고 시스템이 실행되는 동안 계속 실행됩니다. 

### 6) 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.

- 리눅스에서 프로세스 트리의 루트 노드에 위치하는 프로세스는 **`init`** 프로세스입니다.
- **`init`** 프로세스는 시스템의 부팅 과정 중에 처음 시작되며, 모든 다른 프로세스의 조상입니다.
- **`init`** 프로세스는 운영 체제의 핵심 부분으로서 시스템 초기화 및 종료, 사용자 레벨 프로세스의 생성 및 관리, 시스템 서비스의 관리 등을 담당합니다.

# 프로세스 주소 공간에 대해서 설명

프로세스 주소 공간은 프로세스가 메모리 상에서 사용하는 영역을 나타낸다.

각 프로세스는 독립된 주소공간을 가지며, 이를 통해 서로 다른 프로세스들이 메모리를 안전하게 공유하고 동작할 수 있다.

- 코드 영역
    - 프로그램에 내장되어 있는 소스 코드가 들어간다.
    - 수정 불가능한 기계어로 저장되어 있고, 정적인 특징을 가진다.
- 데이터 영역
    - 전역 변수, 정적 변수, 상수등이 저장된다.
    - 초기화 된 전역변수와 정적 변수가 여기에 위치하며, 프로그램이 실행되면 메모리에 할당 된다.
    - 프로그램이 실행될 때 수정 가능
- 힙 영역
    - 동적으로 할당되는 변수들을 담는다
    - 런타임시 크기가 결정된다.
    - 자바에서는 객체가 여기 저장되고 GC에 의해 정리된다.
- 스택 영역
    - 함수 호출 시 지역 변수, 매개변수,리턴값등을 임시로 저장하는 공간
    - 이 영역은 함수 호출시 기록하고 함수의 수행이 완료되면 사라진다.
    - LIFO 방식의 후입선출 방식을 따른다.
    - 컴파일 시 stack 영역의 크기가 결정되기 때문에 무한정 할당할 수 없다.
        - 따라서 재귀함수가 반복해서 호출되거나 할 시 스택 오버 플로우가 발생

### 1) 초기화 하지 않은 변수들은 어디에 저장되나

- 데이터 영역이나 BSS 섹션에 저장된다.
- BSS 영역에서는 초기화가 되지 않은 변수가 0또는 NULL로 초기화된다.

따라서 초기화되지 않은 변수들은 프로그램이 실행될 때 메모리에 할당되지만, 초기화되지 않은 상태로 남아 있습니다. 이 변수들은 사용하기 전에 반드시 명시적으로 초기화해야 합니다. 초기화되지 않은 변수들을 사용하면 예측할 수 없는 동작이 발생할 수 있으며, 프로그램의 안정성과 예측성이 저하될 수 있습니다.

### 2) 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?

- 스택과 힙의 크기는 매우 크다고 단정 짓기는 어렵습니다.
- 일반적으로 스택과 힙의 크기는 프로그램이 실행될 때 동적으로 결정된다.
    - 스택은 컴파일시, 힙은 런타임시
    - 힙 크기는 **운영 체제가 설정**하며, 사용 가능한 메모리에 따라 달라집니다.

### 3) Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?

일반적으로 스택 공간에 접근하는 속도가 힙 공간에 접근하는 속도보다 더 빠르다

- 스택은 LIFO 방식으로 메모리를 할당한다.
    - 즉 마지막으로 할당된 데이터가 먼저 해제된다.
    - 이 방식은 메모리 할당과 해제가 매우 빠르게 이루어지도록한다
    - 또한 CPU 캐시에 자주 저장되므로 데이터 접근 속도가 더욱 향상된다.
- 힙은 동적 메모리 할당을 사용하며, 필요에 따라 메모리를 할당하고 해제한다.
    - 힙은 메모리 할당시 사용 가능한 공간을 찾아야하기 때문에 스택보다 느리다.
    - 캐시에 저장될 가능성이 낮다.

### 4) 다음과 같이 공간을 분할하는 이유가 있을까요?

- 메모리 관리 효율성 향상
    - 메모리를 분할하면 각 영역을 개별적으로 관리할 수 있다.
    - 메모리 사용량을 추적하고 할당/해제를 효율적으로 수행할 수 있게 한다.
- 보안 강화
    - 메모리를 분 할하면 프로그램의 일부분만 변경 가능한 영역과 실행 가능한 코드가 분리될수 있다.
    - 이는 프로그램 실행중에 외부에서 악의적인 코드의 주입을 방지하는데 도움된다.
- 성능 향상
    - 메모리를 분할하면 프로그램의 접근 패턴에 최적화된 메모리 할당 및 해제 알고리즘을 사용할 수 있다.

### 5) 스레드의 주소공간은 어떻게 구성?

- 스레드의 주소 공간은 프로세스의 주소 공간과 매우 유사하지만, 스택을 제외한 다른 부분은 모든 스레드가 공유합니다.
- **스택은 각 스레드마다 독립적으로 할당**되므로 다중 스레드 프로그램에서는 스택의 크기와 관리에 특별한 주의가 필요합니다.

### 6) 스택/힙은 자료 구조 스택/힙 과 연관이 있을까? 그렇다면 각 주소공간의 동작과정과 연계해서 설명

**이름은 같지만 서로 다른 개념입니다.** 하지만, 주소 공간의 동작 방식을 이해하는 데 있어서 자료구조 스택/힙의 특징을 참고할 수 있습니다.

1. **스택 영역**
- 후입 선출 구조를 가진다.
- 함수 호출이 발생하면 해당함수에 필요한 지역변수, 매개변수 등이 스택에 순차적으로 저장된다.
- 함수가 반환되면 스택이 제거되어 이전에 호출된 함수의 스택에 접근할 수 있다.
- 스택은 각 스레드 마다 독립적으로 관리되며, 스택의 크기는 스레드 생성시에 미리 할당되어 있다.
1. **힙 영역**
- 힙 영역은 동적 메모리 할당을 위해 사용된다.
- 힙은 전역적으로 사용되며, 모든 스레드가 공유한다. 따라서 힙에 할당된 메모리는 한 스레드에서 다른 스레드로 전달될 수 있다.
- 힙에 할당됝 메모리는 사용자가 직접 관리해야 하므로, 할당된 메모리의 크기와 해제되는 시점은 프로그래머에게 달려있다.

### 7) IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?

IPC는 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘을 뜻한다

Shared Memory 기법에서는 두 개 이상의 프로세스가 동일한 메모리 공간을 공유합니다. 

IPC(Inter-Process Communication)의 Shared Memory 기법은 프로세스 주소 공간의 힙(Heap) 영역에 들어갑니다. 이는 힙 영역이 모든 프로세스에게 공유되는 메모리 영역이기 때문입니다.

이를 위해서는 각 프로세스가 동일한 메모리 영역을 접근할 수 있어야 합니다. 따라서 Shared Memory 영역은 모든 프로세스에게 공통적으로 접근 가능한 메모리 공간이어야 합니다.

- **힙 영역:** 힙 영역은 동적 메모리 할당에 사용되므로 Shared Memory를 위한 메모리를 할당하는 데 사용할 수 있습니다.

### 8) 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?

1. **스택**
- 일반적을 컴파일시에 결정
- 스택 영역의 크기는 보통 스레드 생성 시 미리 할당되며, 이는 일반적으로 개발자가 직접 조절할 수 없습니다.
- 컴파일러 옵션 또는 프로그래밍 언어 특징에 따라 스택 크기를 조정할 수 있다.
1. **힙**
- 운영체제가 설정
- 프로그램 실행중에 동적 메모리 할당/해제.
    - 사용자가 직접 크기를 수정할 수는 없습니다.

따라서 일반적으로 프로그램 개발자가 직접 스택과 힙 영역의 크기를 조절할 수 있는 경우는 제한적이며, 보통은 운영 체제나 실행 환경의 설정에 따라 크기가 결정됩니다.

# 5. 단기, 중기, 장기 스케쥴러에 대해 설명해주세요

- 장기 스케줄러는 HDD 상의 프로그램을 커널에 등록(or 레디 큐 등록)할 때의 스케줄러
- 단기 스케줄러는 레디 큐의 프로세스를 CPU에 할당하여 실행 상태로 만들때의 스케줄러
- 중기 스케줄러는 메모리에 적재된 프로세스 수를 관리하는 스케줄러

### 1) 현대 OS에는 단,중,장기 스케쥴러를 모두 사용중인가?

- 현대 OS에서는 대부분 장기 스케줄러를 두지 않는다.
- 훨씬 적은 양의 메모리를 활용했던 과거에는 프로세스에 효율적으로 메모리를 할당하기 위해 장기 스케쥴러의 역할이 필요했지만, 비교적 많은 양의 메모리를 활용하는 현대에는 프로세스가 시작되면 장기 스케쥴러 없이 바로 프로세스에 메모리를 할당하여 장기 스케쥴러의 작업없이 레디큐에 넣어주게된다.

### 2) 프로세스의 스케쥴링 상태에 대해 설명해 주세요.

프로세스의 상태는 메모리 할당 상태로 크게 Active(Swapped-in) 상태와 Suspended(Swapped-out) 상태로 나눌 수 있다.

- `Ready` ****: 메모리를 할당 받은 프로세스는 레디 큐에서 프로세서(CPU) 할당을 대기한다.
- `Running` : CPU 스케쥴링(단기 스케쥴링)에 의해 CPU를 할당받은 프로세스는 Running 상태가 되어 작업을 수행한다.
    - 작업 수행 중 스케쥴링에 의해 CPU를 선점 당해 Ready상태가 되거나 I/O 인터럽드 등으로 block이 되어 Asleep 상태로 상태가 전이될 수 있다.
- `Asleep` : 인터럽트 등으로 프로세서 외 다른 자원을 기다리는 상태.
    - 해당 자원을 할당 받으면 Running 상태가 아닌 다시 Ready 상태가 되어 CPU 할당을 대기한다.
- Suspended Ready, Suspended Block : 메모리를 할당 받지 못하거나 빼앗긴 상태.
    - 빼앗기게 된 경우 Memory Image를 Swap device 보관(Swap-out) 했다가 자원을 다시 할당받을 때 해당 Memory Image를 통해 상태를 복구(Swap-In)하게 된다.

### 3) 선점/비선점

**`선점형 스케줄링`**

- 현대 OS가 쓰는 방식으로, 지금 사용하고 있는 프로세스로부터 CPU를 뺏어서, 다른 적절한 프로세스에게 할당해 줄 수 있는 알고리즘
- 장점 : 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다
- 단점 : 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다 (기존의 실행 중인 프로세스 문맥을 백업하고 새로운 프로세스 실행을 위해 문맥을 복구하는 과정)

**`비선점형 스케줄링`**

- 현재 CPU를 사용 중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기
- 장점 : 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다
- 단점 : 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다려야 함> 모든 프로세스가 골고루 자원을 이용하기 어렵다

### 3) 선점/비선점에서 존재할 수 없는 상태가 있을까요

- Asleep(Block) 상태는 작업 실행이 불가능한 상태로, 자원할당을 대기하는 등 사전 정의된 다른 작업이 완료될 때까지 작업 수행이 중지되는 상태이다.
- 따라서 Asleep(Block) 상태는 선점 및 비선점 스케줄링 모두에서 존재할 수 없다.

### 4) 메모리가 부족할 경우, 프로세스는 어떠한 상태로 변화?

- Active(Swapped-In) 상태에서의 프로세스는 더 이상 작업을 수행할 수 없게 되기 때문에 Swap-out되어 Suspended(Swapped-Out) 상태로 전이된다.
- 이 때 메모리 부족으로 필요한 데이터를 가져올 수 없는 경우 Block이 되어 다른 프로세스가 끝나기를 기다리거나, OS가 프로세스를 강제로 종료시켜 Terminated 상태로 전이된다.

# 6. **컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?**

**(컨텍스트 스위칭)**

> 한 프로세스(A)에서 다른 프로세스(B)로 실행 순서가 넘어가면?
> 
> - 기존에 실행 되던 프로세스A는 지금까지의 중간 정보를 백업
> - 뒤이어 실행할 프로세스 B의 문맥을 복구(자연스럽게 실행 중인 프로세스가 바뀜)이처럼 기존의 실행 중인 프로세스 문맥을 백업하고 새로운 프로세스 실행을 위해 문맥을 복구하는 과정을 말한다
1. PCB에서 현재 수행중인 프로세스의 상태 저장
2. 새로운 프로세스를 PCB에서 불러와서 실행

### 1) 프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?

스레드가 더욱 빠르다

요약하면, 프로세스 간의 컨텍스트 스위칭은 시스템 자원을 더 많이 소비하고 오버헤드가 크지만, 스레드 간의 컨텍스트 스위칭은 더 빠르고 효율적이며 자원 공유가 간단합니다.

- TCB가 PCB보다 가볍다.
    - 프로세스 내 스레드는 공유하는 영역이 많아 TCB에는 stack 및 간단한 레지스터 포인터만 저장하기 때문에 읽고 쓸때 빠르다.
- 캐시 메모리를 초기화 하지 않아도 된다.
    - 프로세스 내 스레드 간에 스택과 레지스터 값 등 일부 컨텍스트 정보만 변경

### 2) 컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?

현재 실행중인 프로세스의 상태는 커널 스택에 PCB 형식으로 저장됩니다.

- 저장 되는 정보
    - 프로그램 카운터 : 다음 실행할 명령어의 주소를 가리키는 값
    - 레지스터 상태 : 현재 프로세스의 레지스터 값들이 저장. 이는 프로세스가 중단되고 나중에 다시 재개될 때 동일한 상태로 복구되어야 하는 중요한 정보

### 3) 컨텍스트 스위칭은 언제 일어날까요?

- 인터럽트 처리
    - 하드웨어 장치 또는 소프트웨어 예외가 발생하면 CPU는 현재 실행 중인 프로세스를 중단하고 인터럽트 처리기를 실행합니다.
- 시스템 호출
    - 프로세스가 운영체제 서비스를 요청하기 위해 시스템 호출을 수행하면 컨텍스트 스위칭이 발생합니다.
- 프로세스 스케쥴링
- 프로세스 생성 또는 종료
- 자원 부족
- 멀티 코어 환경

# **7. 프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?**

> CPU스케줄링의 대표적인 7가지 알고리즘
> 
> 1. 선입 선처리 스케줄링
> 1. 최단 작업 우선 스케줄링
> 1. 라운드 로빈 스케줄링
> 1. 최소 잔여 시간 우선 스케줄링
> 1. 우선순위 스케줄링
> 1. 다단계 큐 스케줄링
> 1. 다단계 피드백 큐 스케줄링

**`선입 선처리 스케줄링`**

- FCFS ( First Come First Served) 스케줄링
- 단순히 **준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링**
- 먼저 CPU를 요청한 프로세스부터 CPU 할당
- **단점 : 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용 (=호위 효과)**

**`최단 작업 우선 스케줄링`**

- SJF(Shortest Job First) 스케줄링
- 호위 효과를 방지하려면?
- CPU 사용이 긴 프로세스는 나중에 실행, **CPU 사용 시간이 짧은 프로세스는 먼저 실행**
- **CPU 사용 시간이 가장 짧은 프로세스부터 처리하는 스케줄링 방식**

**`라운드 로빈 스케줄링`**

- RR(Round Robin) 스케줄링
- 선입 선처리 스케줄링 + **타임 슬라이스(time slice)**
- 타임 슬라이스(Time Slice) : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 **선점형 스케줄링**
    - 큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되, 정해진 시간만큼만 이용
    - 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입(문맥교환)

**`타임 슬라이스의 중요성`**

> 타임 슬라이스가 커진다면,
> 
> 
> 선입 선처리 스케줄링(FCFS)의 문제점인 **호위 효과**(프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용)가 생길 수 있고,
> 
> *타임 슬라이스가 지나치게 작으면,*
> 
> 문맥 교환에 발생하는 오버헤드 때문에 CPU의 부담이 가는 우려가 있다
> 

**`최소 잔여 시간 우선 스케줄링`**

- SRT(Shortest Remaining Time) 스케줄링
- 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링 (선점형 스케줄링)
- **정해진 시간(타임 슬라이스)만큼 CPU를 이용하되,** 다음으로 CPU를 사용할 프로세스는 **남은 작업 시간이 가장 적은 프로세스 선택**

**`우선순위 스케줄링`**

- Priority Scheduling
- 프로세스들에게 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행
- 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링
- 최단 작업 우선 스케줄링, 최소 잔여 시스템 스케줄링 < 우선순위 스케줄링
- 문제점
    - 우선순위가 계속 높은 프로세스만 실행이 되어서 **기아 현상**(starvation)이 발생한다
    - 우선순위가 낮은 프로세스는 준비 큐에 먼저 삽입이 되었음에도 불구하고 실행이 연기 된다
- 해결책**에이징 : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식**대기 중인 프로세스의 우선수위를 마치 나이 먹듯 점차 증가시키는 방법(우선순위가 낮아도 언젠가는 우선순위가 높아진다)

**`다단계 큐 스케줄링`**

- Multilevel queue 스케줄링
- 우선순위 스케줄링의 발전된 형태
- **우선순위별로 준비 큐를 여러개 사용하는 스케줄링 방식**
    - 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리
    - **우선순위가 가장 높은 큐가 비어 있으면, 그 다음 우선순위 큐에 있는 프로세스 처리**
- 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해진다
- 하지만 프로세스들이 큐 사이를 이동할 수 없어서, 우선순위가 낮은 프로세스는 계속 연기될 여지가 있다> 기아현상 재발 가능

**`다단계 피드백 큐 스케줄링`**

- Multilevel feedback queue 스케줄링
- 다단계 큐 스케줄링의 발전된 형태
- 다단계 큐 스케줄링에서는 기본적으로 큐간의 이동 불가
- **큐 간의 이동이 가능**한 다단계 큐 스케줄링타임 슬라이스 동안 실행을 다 못 끝내겠다면, 일단 낮은 우선수위로 보낸다고 이해하자
- 자연스럽게 CPU집중 프로세스의 우선순위는 상대적으로 낮아지고, 입출력 집중 프로세스의 우선순위는 상대적으로 높아짐
- 에이징 기법을 적용하여 기아 현상을 예방할 수 있다

### 1) RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.

**`타임 슬라이스의 중요성`**

> 타임 슬라이스가 커진다면,
> 

### 2) 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?

- 우선순위를 기반으로 할당하는 멀티 레벨 피드백 큐, 멀티 레벨 큐등을 사용하면 우선순위가 높은 것부터 실행하기 때문에 좋다.

### 3) 동시성과 병렬성의 차이에 대해 설명해 주세요.

### 동시성

- 동시성이란 CPU가 쉬는 쉬간을 최대한 낮추는 것
- task를 번갈아 가면서 실행

### 병렬성

- 실제로 동시에 여러작업이 처리
- 멀티 코어에서 멀티 스레드 동작

### **3) 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?**

- 프로세스가 요구하는 작업 및 프로세싱 시간은 달라지는데 멀티레벨큐로는 이를 대응할 수 없다.
- 아주 오래 걸리는 작업이 계속 우선순위를 높게 차지한다면 다른 프로세스들의 응답 시간 및 TurnArround Time이 높아진다.
- 이를 해결한것이 MLFQ

### 4) FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요?

**FIFO 스케줄러의 장점:**

- **간단하고 효율적:** 구현 및 이해가 쉽고 오버헤드가 적습니다.
- **공정성:** 작업이 도착한 순서대로 처리되어 모든 작업에 동일한 기회를 제공합니다.
- **예측 가능성:** 작업 처리 시간을 예측하기 쉬워 시스템 관리가 용이합니다.
1. **자원 예약**: 예를 들어, 프린터나 네트워크 자원과 같이 선입선출이 필요한 자원 예약 시스템에서 사용될 수 있습니다.
2. **단순한 환경**: 작업들 간에 실행 우선순위를 정하지 않아도 되는 간단한 환경에서는 FIFO 스케줄러를 사용할 수 있습니다.

### 3) 우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?

스레드 스케줄링은 일반적으로 다음과 같은 방식으로 이루어집니다:

1. **유저 수준 스케줄링(User-Level Scheduling)**: 어떤 스레드가 CPU를 얼마나 할당받을지 결정하는 것은 일반적으로 운영 체제가 아닌 해당 프로세스의 유저 수준 라이브러리 또는 스레드 라이브러리에 의해 이루어집니다. 이러한 스케줄링은 프로세스 내에서 스레드 간의 우선 순위나 일부 사용자 정의된 정책에 따라 이루어집니다.
2. **커널 수준 스케줄링(Kernel-Level Scheduling)**: 실제로 CPU를 할당받는 스레드는 운영 체제의 커널에 의해 결정됩니다. 커널은 시스템 전반의 자원 할당을 관리하고, 다중 스레드 환경에서는 각 스레드에게 CPU 시간을 할당하고 관리합니다.

이러한 스레드 스케줄링은 일반적으로 프로세스 스케줄링과 유사한 방식으로 이루어지지만, 스레드 간의 특별한 상호 작용과 자원 공유를 고려하여 보다 세밀하게 조정될 수 있습니다.

### 4) 유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?

1. **유저 스레드의 스케줄링**:
    - 유저 수준 스레드의 스케줄링은 주로 프로세스 내부에서 이루어집니다.
    - 유저 수준 스레드는 해당 프로세스의 사용자 수준 라이브러리나 스레드 라이브러리에 의해 관리됩니다.
    - 일반적으로 사용자 정의된 스케줄링 정책 또는 우선 순위를 기반으로 하며, 운영 체제에 의해 직접적으로 영향을 받지 않습니다.
2. **커널 스레드의 스케줄링**:
    - 커널 수준 스레드의 스케줄링은 운영 체제의 커널에 의해 관리됩니다.
    - 커널 스레드는 프로세스의 커널 영역에서 직접적으로 관리되며, 운영 체제의 자원 관리 정책에 따라 CPU 시간을 할당받습니다.
    - 일반적으로 운영 체제는 커널 수준 스레드의 우선 순위, CPU 점유 시간 등을 고려하여 스케줄링을 수행합니다.
    
    따라서 유저 스레드와 커널 스레드는 서로 다른 수준에서 관리되므로, 스케줄링 알고리즘도 일반적으로 다르다.
    

# 23. **동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해주세요.**

- 블로킹은 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날때까지 기다렸다가 자신의 작업을 시작
- 논 블로킹은 다른 주체의 작업에 관련이 없이 자신의 작업을 하는것 (제어권이 본인한테)
- 동기는 요청한 작업에 대해 완료 여부를 따져 순차적으로 처리하는것
- 비동기는 동기와 반대로 요청한 작업에 대해 완료 여부를 따지지 않기 때문에 다음 작업을 그대로 수행하는것
- 비동기 이점
    - I/O 작업과 같은 느린 작업이 발생할 때, 기다리지 않고 다른 작업을 처리하면서 동시에 처리하여 멀티 작업을 진행할수 있기 때문이다.
- 동기는 커피집에서 줄을 한줄로 서있고 주문을 하고 나올 때까지 기다려라 하는것
- 비동기는 커핒딥에서 캐셔에게 주문을 하면 진동벨을 주고 옆에서 직원이 주는것을 받아가는 것

블로킹/논블로킹은 다른 주체가 작업할 때 자신의 제어권이 있는지 없는지로 볼 수 있고, 동기/비동기는 결과를 돌려주었을 때 결과에 관심이 많은지 없는지로 볼 수 있습니다.

### 1) **그렇다면, 동기이면서 논블로킹이고, 비동기이면서 블로킹인 경우는 의미가 있다고 할 수 있나요?**

- 동기-블로킹 : 블로킹의 관점은 제어권에 있기 때문에 다른 작업이 시작되는 동안 동작하지 않는다.동기의 관점은 결과의 처리이기 때문에 결과를 반환하면 해당 업무를 바로 처리하게 된다
    
    ex) 자바 입출력
    
- 동기-논블로킹 : 논블로킹은 자신의 제어권을 가지고 일을 하는 것입니다. 그런데 동기는 결과에 관심이 많으므로 중간중간마다 결과값이 나왔는지 주기적으로 물어보다가 결과값이 나오면, 해당 결과를 가지고 업무를 처리
    
    이와 같은 동기-논블로킹 방식은 특정 작업의 결과가 필요한 경우에도 프로그램의 실행 흐름이 일시 중단되지 않고 다른 작업을 병렬로 처리할 수 있게 해준다.
    
- 비동기-블로킹 : 블로킹이기 때문에 자신의 작업에 대한 제어권이 없고, 비동기이기 때문에 결과를 바로 처리하지 않아도 된다.
    
    일반적으로 사용되지 않고, 특수한 상황에서만 사용된다.
    
- 비동기-논블로킹 : 논블로킹은 다른 작업이 시작되어도 자신이 하던 작업은 멈추지 않는. 따라서 양쪽에서 서로 각자 작업을 처리하게 되고, 다른 작업이 결과가 끝나면 바로 처리하지 않고 자신의 일이 끝나면 처리하게 된다.

### 2) I/O 멀티플렉싱에 대해 설명해 주세요.

- 여러 I/O 작업을 동시에 처리하거나 관리하기 위한 기술
- 요 목적은 프로그램이 블로킹 없이 여러 I/O 작업을 동시에 처리할 수 있도록 하는 것

### 3) 논블로킹 I/O를 수행한다고 하면, 그 결과를 어떻게 수신할 수 있나요?

논블로킹 I/O를 수행하면, 결과를 기다리지 않고 프로그램이 다른 작업을 수행할 수 있습니다. 그러나 결과를 수신하려면 추가적인 메커니즘이 필요합니다. 주로 사용되는 메커니즘은 다음과 같습니다:

1. **비동기(Asynchronous) 이벤트 처리**: 논블로킹 I/O 작업을 시작한 후, I/O 완료 이벤트를 기다리지 않고 프로그램은 다른 작업을 수행합니다. 이후 I/O 완료 이벤트가 발생하면 해당 이벤트를 처리하여 결과를 수신합니다.
2. **콜백(Callback) 함수**: 논블로킹 I/O 작업을 시작할 때 콜백 함수를 지정할 수 있습니다. 이 콜백 함수는 I/O 작업이 완료되었을 때 호출됩니다. 따라서 콜백 함수를 통해 결과를 처리할 수 있습니다.
3. **이벤트 루프(Event Loop)**: 일반적으로 비동기 I/O를 지원하는 프레임워크나 라이브러리는 이벤트 루프를 사용합니다. 이벤트 루프는 다양한 이벤트를 감지하고 처리하는 메커니즘을 제공합니다. 따라서 논블로킹 I/O 작업의 완료 이벤트를 이벤트 루프를 통해 수신하여 결과를 처리할 수 있습니다.
4. **Future나 Promise**: 일부 언어나 라이브러리는 Future나 Promise와 같은 추상화를 제공하여 비동기 작업의 결과를 표현합니다. 이러한 추상화를 사용하여 논블로킹 I/O 작업의 결과를 수신하고 처리할 수 있습니다.
