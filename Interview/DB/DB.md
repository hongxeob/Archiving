# 1. Key에 대해 설명해주세요

- 키란 데이터의 식별자의 역할을 하는 것을 의미한다.

### 기본키

- 후보키들 중에서 하나를 선택한 키로 최소성과 유일성을 만족한다.
- Null값을 가질 수 없다.
- 오직 하나
- 중복 X

### 슈퍼키

- 각 행을 유일하게 식별할 수 있는 하나 혹은 그 이상의 **속성의 집합**
- 유일성을 만족한다.

### 후보키

- 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합

### 대체키

- 후보키가 두개 이상일 경우 그중에서 **기본키로 지정하고 남은 키**

### 외래키

- 다른 테이블의 데이터를 참조할 때 사용하는 키
- **참조될 테이블에서 기본키로 설정되어 있어야 한다.**

## `1)기본키는 수정이 가능한가요`

- 연관관계가 존재하지 않는 기본키는 수정은 가능하나, 유니크한 값이어야한다.
- cascade 설정이 되어있지 않는 연관관계에 있는 기본키 또는 외래키는 수정이 불가능하다.
- cacade 설정이 되어 있는 연관관계의 경우 외래키는 수정되지 않는다.

## `2)MySQL의 경우 기본키를 설정하지 않아도 테이블이 만들어지는 이유?`

- MySQL에서 자체적으로 테이블의 속성 중 값에 Null 값이 없고, 레코드마다 고유한 첫 속성을 골라 클러스터형 인덱스로 지정한다.
- 만약 테이블에 기본키 또는 적절한 고유 값의 인덱스가 존재하지 않는다면, InnoDB가 자체적으로 클러스터형 인덱스를 생성한다.
    - **클러스터형 인덱스** : 해당 키 값을 기반으로 테이블의 데이터 행을 정렬하고 저장한다. 데이터는 오직 하나의 순서로 정렬될 수 있기에 클러스터형 인덱스는 테이블당 최대 한개만 존재 가능
    - 비클러스터형 인덱스 : 비클러스터형 인덱스 키값을 가지고 각 키 값 레코드는 그 키값을 가지는 레코드를 향한 포인터를 가진다.

## `3)외래키의 값은 NULL이 들어올 수 있나요?`

- 가능하다.
- ex) 학생은 하나의 동아리를 갖는다. 하지만 신입생은 아직 동아리가 정해지지 않았을 수도 있다.

## `4)어떤 칼럼의 정의에 Unique 키워드가 붙는다고 가정하면, 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까`

- 처음 값을 추가할 경우에는 전체 칼럼을 검색해야 해서 느리다. (유니크 한지 아닌지 확인)
- 하지만 이후 조회시에는하나의 index를 찾았을 때 유니크 값이 보장되니 빠르게 검색 가능

# 2. RDB와 NoSQL의 차이

- RDB
    - 엄격한 데이터 구조를 가지고 있다.
    - 데이터 중복없이 한번반 저장 (무결성)
    - 데이터의 분류, 정렬, 탐색 속도가 비교적 빠르다
    - 시스템이 커지면 쿼리가 복잡해진다.
    - 수평적 확장이 까다롭다
    - **`장점`**
        - 정해진 스키마에 따라 데이터를 저장해서 명확한 데이터 구조를 보장한다.
        - 각 데이터를 중복없이 한번만 저장할 수 있다.
    - **`단점`**
        - 시스템이 커지면 Join문이 많아져서 복잡한 쿼리가 필요하다.
        - 성능 향상을 위해서는 스케일 업이 필요하다. 비용이 겁나 는다.
        - 스키마 때문에 데이터가 유연하지 못한다. 그래서 스키마 변경이 일어나면 일이 번거로워진다.
        - 클라우드 분산 환경에 적합하지 않다.
- NoSQL
    - 유연한 데이터 구조
    - RDBMS와 달리 테이블간 관계를 정의하지 않으므로 테이블간 Join 불가
    - 새로운 필드 추가가 자유롭다
    - 데이터 중복이 발생 할 수 있다. (레디스의 경우 Set 컬렉션으로 방지 가능)
    - 데이터 변경시 모든 컬렉션에서 수정 필요
    - RDB는 성능 향상을 위해서는 스케일업이 필요한데 비용을 많이 들여서 장비를 업그레이드 해야한다.
      하지만 NoSQL은 스케일 아웃을 통해 여러대의 데이터에 분산하여 저장하는 목표로 등장했다.

### `1) NoSQL의 강점과, 약점?`

- **`장점`**
    - 스키마가 없어 유연하고 자유로운 데이터 구조를 가진다. 언제든지 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있다.
    - 데이터 분산에 용이하다.
    - 성능 향상을 위해 스케일업/아웃이 둘다 활용 가능
- **`단점`**
    - 데이터 중복이 발생할 수 있다.
    - 데이터 무결성,정합성 보장 X
    - 중복된 데이터가 변경되면 수정을 모든 컬렉션에서 수정해야한다.
    - 스키마가 없어 명확한 데이터 구조를 보장X

### `2) RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 수 있을까요?`

- RDB는 테이블간 관계를 맺고 있어 이로 인해 Join문을 필요로 한다. 하지만 조인 문이 많아지게 되면 여러 테이블을 조회해야하기 때문에 부하가 걸릴 수 있다.

# 6. **RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명**

### **레플리케이션**

- 여러개의 데이터베이스를 권한에 따라 **수직적**인 구조로 구축하는 방식 `(마스터-슬레이브)`
- 마스터 노드는 쓰기 작업, 슬레이브 노드는 읽기 작업만 수행한다.
- **비동기** 방식으로 노드들간의 데이터를 동기화 한다.
    - 마스터-슬레이브 간의 데이터 무결성 검사를 하지 않는다.
- 동작 방식:
    1. 마스터 노드에 쓰기 트랜잭션이 수행된다
    2. 마스터 노드는 데이터를 저장하고 트랜잭션에 대한 로그를 Binary Log에 기록한다
    3. 슬레이브 노드의 IO 스레드는 마스터 노드의 Binary Log을 Replay Log에 복사한다
    4. 슬레이브 노드의 SQL 스레드는 Replay Log를 한줄씩 읽어 데이터를 저장한다

`Binary Log`: DB 변경 내용을 기록하는데 이용하는 로그.

`Relay Log:` Slave DB에만 위치하고, 마스터 DB의 Binary Log을 복사해 저장하는데 이용하는 로그.

- 장점
    - DB 요청의 대부분이 읽기 작업이라서, 레플리케이션만으로도 성능을 높일 수 있다.
    - **비동기** 방식이라서 지연 시간이 거의 없다.
- 단점
    - 노드들간의 데이터 동기화가 100% 보장되지 않아서 **데이터 일관성을 보장하지 못할 수 있다.**
    - 마스터 노드가 죽으면 복구 및 대처가 까다롭다.

### 클러스터링

- 여러개의 데이터 베이스를 **수평적**인 구조로 구축하는 방식
- 분산환경을 구성하여 Single Point of Failure (SPOF) 같은 문제를 해결할 수 있는 Fail Over 시스템을 구축하는 것을 목적으로 한다.
- **동기** 방식으로 노드들간의 데이터를 동기화 한다.
- 동작 방식:
    1. 1개의 노드에 쓰기 트랜잭션이 수행되고, 커밋 실행
    2. 실제 디스크에 내용을 쓰기전에 다른 노드로 데이터 복제 요청
    3. 다른 노드에서 복제 요청을 수락했다는 신호를 보내고, 디스크에 쓰기 시작
    4. 다른 노드로 부터 신호를 받으면 실제 디스크에 데이터를 저장.
- 장점
    - 노드들 간 데이터를 동기화 하여 항상 일관성있는 데이터를 얻을 수 있다.
    - 노드가 죽어도 다른 노드가 살아 있으므로 시스템 장애가 발생하지 않는다.
- 단점
    - 여러 노드간 데이터를 동기화하는 시간이 필요해서 레플리케이션보다 쓰기 성능이 떨어진다.
    - 장애가 전파되면 처리가 까다롭다.
    - 데이터 동기화에 의해 스케일링에 한계가 존재한다.

### RDBMS에서 레플리케이션/클러스터링 적용

- 레플리케이션으로 구축하면 마스터-슬레이브 구조로 구성해서 마스터는 DML만 처리하고 슬레이브는 읽기만 수행
    - 사용자가 많아져 부하가 증가할 시 슬레이브를 증설
    - 슬레이브를 증설하면 부하 분산으로 인해 로드밸런서를 구축
- 클러스터링으로 구축하면 management node, data node, SQL node로 구성한다
    - 권장: Management node 2대, Data node 2대, SQL node 2대
    - 공유디스크나 락에 대한 성능 저하는 발생하지 않는다
    - Data node를 초기에 구축하면 데이터 증가로 인한 노드 추가시 시스템 전체 정지 후 재구축해야 하는 단점이 존재한다

### NoSQL에서 레플리케이션/클러스터링 적용

- 레플리케이션은 RDBMS의 적용과 같다.
- (몽고) 클러스터링으로 구축하면 많은 데이터를 여러 노드에 부산 저장하는 방식으로 3종류 서버를 구성
    - Mongod, Mongod configsvr, mongs
    - 장점: 수평적 확장성, 읽기/쓰기 연산 성능 향상

## `1) 이러한 분산 환경에선, 트랜잭션 관리를 어떻게 할 수 있을까요`

- 대표적인 분산 트랜잭션 관리 방안으로는 `2Phase Commit`과 `Saga Pattern`이 존재

### `2Phase Commit (2PC) 알고리즘`

- 2pc 알고리즘은 분산 시스템에서 트랜잭션을 변경할 수 있는 기능을 제공하는데, 제한 사항이 존재
- 두 phase는 투표 단계와 커밋 단계이다.
    1. **Voting Phase (투표 단계)**:
        - 트랜잭션을 커밋하기 전에, 트랜잭션 코디네이터는 모든 참여자에게 투표 요청을 보냅니다.
        - 참여자는 투표를 통해 트랜잭션을 수행할 수 있는지 여부를 통지합니다. 각 참여자는 "예" 또는 "아니오"로 응답합니다.
    2. **Commit Phase (커밋 단계)**:
        - 모든 참여자가 "예"로 투표한 경우에만, 트랜잭션 코디네이터는 커밋을 진행합니다.
        - 트랜잭션 코디네이터는 모든 참여자에게 커밋을 수행하라는 메시지를 보내고, 참여자는 커밋을 수행합니다.
        - 하나의 참여자라도 "아니오"로 투표하면, 트랜잭션은 롤백됩니다.
    3. **결론**
        - 2PC는 서비스가 증가할수록 시스템의 대기시간이 길어지고, 이는 응답시간의 증가를 초래한다.
        - 특히 락을 걸어야 하는 row의 범위가 넓거나 트랜잭션 기간이 길면 시스템에 엄청난 대기시간을 발생시키니까 2PC는 일반적으로 **수명이 짧은 작업에만 사용하는 것을 권장**한다.

### `SAGA pattern`

- Saga Pattern은 마이크로 서비스에서 데이터 일관성을 관리하는 방법입니다.
- 각 서비스는 로컬 트랜잭션을 가지고 있으며, 해당 서비스 데이터를 업데이트하며**메시지 또는 이벤트를 발행**해서, 다음 단계 트랜잭션을 호출하게 됩니다.
- 만약, 해당 프로세스가 실패하게 되면 데이터 정합성을 맞추기 위해 이전 트랜잭션에 대해**보상 트랜잭션**을 실행합니다.
- NoSQL 같이 분산 트랜잭션 처리를 지원하지 않거나, 각기 다른 서비스에서 다른 DB 밴더사를 이용할 경우에도 Saga Pattenrn을 이용해서 데이터 일관성을 보장 받을 수 있습니다.

**Choreography 방식**

- 각 서비스간 이벤트를 주고받는 pub/sub 방식이다. 중간에 카프카와 같은 메세지 큐를 통해 비동기 방식으올 전달한다.
- 프로세스를 진행하다가 여러 서비스를 거쳐 서비스(Stock, Payment)에서 실패(예외처리 혹은 장애)가 난다면**보상 트랜잭션 이벤트**를 발행합니다.
- 장점으론, 간단한 workflow에 적합하며 추가 서비스 구현 및 유지관리가 필요하지 않아서 간단하게 세팅할 수 있습니다.
- 단점으론, 트랜잭션을 시뮬레이션하기 위해 모든 서비스를 실행해야하기 때문에 통합테스트와 디버깅이 어려운 점이 있습니다.

## `2) 마스터, 슬레이브 데이터 동기화 전까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?`

- 완벽하게 동기화를 구현하기는 어렵기 때문에 실시간성을 보장해야 하는 쿼리는 마스터로 처리한다.

## `3) 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.`

- 락들의 경합이 발생하면 블로킹 (Blocking)이고, 이때 특정 세션이 작업을 진행하지 못하고 멈추게 된다.
- 공유락(s락) - 배타락(x락) / 배타락-배타락 관계에서 블로킹이 발생할 수 있는데, 이를 해결하려면 트랙재션 커밋 또는 롤백이 필요하다.
- **교착상태 (Deadlock)** 는 두개 이상의 트랜잭션이 특정 자원의 락을 획득한 채 다른 트랜잭션이 소유하고 있는 락을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태를 말한다.

### 데드락 예방 기법

1. 각 트랜잭션이 실행되기 전에 필요한 모든 자원을 락한다 (병행성은 떨어진다)
2. SET LOCK_TIMEOUT 문을 통해 일정 시간이 지나면 쿼리를 취소한다

### 데드락 회피 기법

회피 기법은 자원을 할당할 때 타임스탬프를 활용해서 교착상태가 일어나지 않도록 회피하는 방법이다.

- **Wait-Die 방식**:
    - 트랜잭션 A가 트랜잭션 B에 의해 락된 데이터를 요청할 때 트랜잭션 A가 먼저 들어온 트랜잭션이라면 대기한다
    - 트랜잭션 A가 나중에 들어온 트랜잭션이라면 포기(Die)하고 나중에 다시 요청한다
- **Wound-Wait 방식**:
    - 트랜잭션 A가 트랜잭션 B보다 먼저 들어온 트랜잭션이면 데이터를 선점(Wound)한다
    - 트랜잭션 A가 트랜잭션 B보다 나중에 들어온 트랜잭션이라면 대기(Wait)한다

### 낙관적 병행 제어 기법

트랜잭션이 실행되는 동안에는 검사를 수행하지 않고, 트랜잭션이 커밋된 후에 데이터에 문제가 있다면 롤백한다

판독 > 확인 > 기록의 단계를 따르고, 확인 단계를 성공적으로 거친 트랜잭션만 기록 단계를 수행할 수 있다

### 빈도 줄이기

1. 트랜잭션을 자주 커밋한다
2. 정해진 순서로 테이블에 접근한다
3. 읽기 락 획득(SELECT ~ FOR UPDATE)의 사용을 피한다
4. 테이블 단위의 락을 통해 갱신을 직렬화한다
5. 인덱스 설계: UPDATE시 인덱스를 타지 않으면 테이블 전체에 락이 걸릴 수 있다
6. 고립수준을 낮춘다

## `4)샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?`

샤딩은 데이터베이스 트래픽을 분산할 수 있는 중요한 수단으로, 각 DB 서버에서 **데이터를 분할해서 저장**하는 방식이다. 해당 데이터에 접근할 때는 샤딩키를 사용하여 동적으로 DB 서버를 매핑하는 과정이
필요하다.

샤딩을 이용하면 특정 DB의 장애가 전면 장애로 이어지는 것을 방지할 수 있다.

### 모듈러 샤딩

- PK를 모듈러 연산한 결과로 DB를 라우팅 하는 방식이다 (ex Key % 3)
- 장점
    - 레인지 샤딩에 비해 데이터가 균일하게 분산된다.
    - 트래픽을 안정적으로 소화
    - 데이터베이스 리소스를 최대한으로 활용한다.
- 단점
    - DB를 추가 증설하는 과정에서 이미 적재된 데이터의 재정렬이 필요하다.

### 레인지 샤딩

- PK 범위를 기준으로 데이터 베이스를 특정한다 (ex : 1~3은 샤드1, 4~6은 샤드2 …)
- 장점
    - 모듈러 샤딩에 비해 증설에 재정렬 비용이 들지 않는다.
- 단점
    - 일부 DB에 데이터가 몰릴 수 있다.
- 데이터가 급격히 증가할 여지가 있다면 적절한 방식이다.
    - 하지만 트래픽 분산이 균등하지 않을 수 있기 때문에 트래픽이 몰리는 데이터베이스는 분산시키고, 트래픽이 저조한 데이터베이스는 통합시키는 과정이 필요하다.

### 샤딩을 대체해보자

1. 모든 컴포넌트들이 하나의 서버에 있는 애플리케이션이면 원격 데이터베이스를 사용할 수 있다
2. 읽기 퍼포먼스가 문제라면 캐싱을 활용하자
3. 마스터-슬레이브 구조를 활용하자
4. scale up이 샤딩에 비해 공수가 적다.

시스템의 규모와 성능 요구사항을 고려하여 먼저 레플리케이션을 선택하고, 시스템이 성장하고 부하가 증가할 경우에는 샤딩을 도입하는 것이 적합할 것입니다.

# `7. 정규화가 무엇인가요?`

이상현상이 있는 릴레이션을 분해해 이상 현상을 없앤 과정으로, 이상현상이 존재하는 릴레이션을 분해해서 여러개의 릴레이션을 생성한다. 정규형이 높아질수록 이상현상은 줄어들게 된다.

- 장점
    - 이상현상을 제거할 수 있다.
    - 정규화된 DB구조에서 새로운 데이터형의 추가로 인한 확장시, 그 구조를 변경하지 않거나 일부만 변경해도 된다.
    - DB와 연동된 응용프로그램에 최소한의 영향만 미친다.
- 단점
    - 테이블 분해로 인해 테이블간 Join 연산이 많아진다.
        - 그러다보니 반정규화가 필요할수도 있다.

**정규화의 3가지 원칙**

1. 정보의 무손실 : 분해된 릴레이션이 표현하는 정보는 분해 전 정보를 모두 포함해야한다.
2. 최소 데이터 중복 : 이상현상을 제거하고, 데이터 중복을 최소화 해야한다.
3. 분리의 원칙 : 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리해서 표현해야한다.

### 제 1정규형 (1NF)

1. 각 컬럼이 하나의 속성만을 가져야 한다
2. 하나의 컬럼은 같은 종류의 값을 가져야 한다
3. 각 컬럼이 유일한 이름을 가져야 한다
4. 컬럼의 순서가 상관 없어야 한다

### 제 2정규형 (2NF)

1. 제 1정규형의 조건을 만족해야 한다
2. 모든 컬럼이 부분적 종속(Partial Dependency)이 없어야 한다. 즉, 모든 컬럼이 완전 함수 종속을 만족해야 한다

> 부분적 종속: 기본키 중에 특정 컬럼에만 종속됨을 의미한다.
>
>
> 완전 함수 종속: 기본키의 부분집합이 결정자가 되어서는 안됨을 의미한다
>

### 제 3정규형 (3NF)

1. 제 2정규형의 조건을 만족해야 한다
2. 기본키를 제외한 속성들 간의 이행 종속성 (Transitive Dependency)이 없어야 한다

> 이행 종속성: A->B, B->C일 때 A->C가 성립한다. A를 알면 B를 알고, 이를 통해 C를 알 수 있다.
>

### BCNF (Boyce-Codd Normal Form)

1. 제 3정규형을 만족해야 한다
2. 모든 결정자가 후보키 집합에 속해야 한다. 즉, 후보키 집합에 없는 컬럼이 결정자가 되어서는 안된다.

### **1)정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.**

1. **삽입 이상**
    - 튜플 삽입시 특정 속성에 해당하는 값이 없어 null을 입력해야하는 현상
2. 삭제 이상
    - 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
3. 갱신 이상
    - 튜플 갱신 시 중복된 데이터의 일부만 갱신되어 일어나는 데이터 불일치 현상

### 2)정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.

### `3) 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.`

역정규화란 성능향상을 위해 정규화된 데이터 모델을 통합하는 작업으로, 데이터 통합/분할/추가, 중복 속성 추가 등으로 구현할 수 있다.

역정규화를 수행하면 테이블이 단순해져서 관리 효율성이 증가하지만, 데이터 무결성/일관성은 보장되지 않을 수 있다.

**역정규화가 필요할때**

- 수행 속도가 현저히 느릴때
- 테이블의 조인 연산이 지나치게 많이 필요해서 데이터를 조회하는 것이 어려울 때
- 테이블에 많은 데이터가 있고, 다량의 범위 혹은 특점 범위를 자주 처리해야 하는 경우

# `8. View가 무엇이고, 언제 사용?`

### View의 특징

- 뷰는 테이블에서 유도된 임시 테이블이라서 기본 테이블과 같은 형태의 구조를 사용한다
- 뷰는 가상 테이블이라서 물리적으로 구현돼있지 않다
- 데이터의 논리적 독립성을 제공할 수 있다
- 필요한 데이터만 뷰로 정의해서 처리할 수 있어서 관리와 쿼리가 쉬워진다
- 뷰를 통해서만 데이터에 접근하면 뷰에 나타나지 않은 데이터를 안전히 보호할 수 있다
- 기본 테이블의 기본키를 포함한 속성 집합으로 뷰를 구성해야지만 삽입/삭제/갱신/연산이 가능하다
- 일단 정의된 뷰는 다른 뷰의 정의의 기초가 될 수 있다
- 뷰가 정의된 기본 테이블/뷰를 삭제하면 그 뷰도 자동으로 삭제된다

### View의 장점

- 논리적 데이터 독립성을 제공한다
- 동일 데이터에 대해 동시에 여러 사용자의 상이한 요구를 지원한다
- 사용자의 데이터관리가 쉬워진다
- 접근 제어를 통한 보안을 제공한다

### View의 단점

- 독립적인 인덱스를 가질 수 없다
- 뷰의의 정의는 변경할 수 없다: 변경이 필요하면 삭제 후 재생성해야 한다
- 뷰로 구성된 내용에 대한 연산에 제약이 따른다

## `1) 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?`

넹

# `13. Schema가 무엇인가요?`

**스키마**는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술하는 메타데이터의 집합이다.

- 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의한다
- 불변의 특성을 갖는다
- 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나뉜다

### **1) Schema의 3계층에 대해 설명해 주세요.**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/937e5cb8-e884-4958-ac79-ea61113dac23/d9a68896-cd22-475f-bac5-f02d2769b34e/Untitled.png)

### 외부 스키마 (External Schema)

- 사용자/응용프로그래머가 각 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것으로, DML을 사용해 데이터를 이용한다
- 전체 데이터베이스의 한 논리적인 부분만 보는 것으로 서브 스키마(Sub Schema)라고도 불린다
- 하나의 데이터베이스 시스템에는 여러개의 외부 스키마가 존재할 수 있고, 하나의 외부 스키마를 여러 응용 프로그램/사용자가 공용할 수 있다
- 같은 데이터베이스에 대해서도 서로 다른 관점을 정의할 수 있다
- 사용자 뷰와도 같다

### 개념 스키마 (Conceptual Schema)

- 전체적인 뷰와 같다
- 데이터베이스의 전체적인 논리적 구조다
- 모든 응용 프로그램/사용자가 필요로 하는 데이터를 종합한 전체의 데이터베이스로 하나만 존재한다
- 개체간의 관계와 제약 조건을 나타내고 데이터베이스의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의한다
- DDL과 DCL을 사용해 구조를 설계한다
- 데이터베이스 관리자에 의해 구성된다

> 💡 **DDL (데이터 정의 언어)**:
> - **목적**: DDL은 데이터베이스의 구조와 스키마를 정의하는 데 사용됩니다.
> - **동작**: CREATE, ALTER, DROP, TRUNCATE 등의 명령을 포함합니다.
> - **예시**: 테이블 생성, 테이블 구조 변경, 테이블 삭제 등.
> - **주요 포인트**: 데이터베이스의 기본 구조를 정의하고 조작합니다.


> 💡 **DML (데이터 조작 언어)**:
> - **목적**: DML은 데이터를 검색, 삽입, 수정 및 삭제하는 데 사용됩니다.
> - **동작**: SELECT, INSERT, UPDATE, DELETE 등의 명령을 포함합니다.
> - **예시**: 데이터 삽입, 데이터 수정, 데이터 삭제 등.
> - **주요 포인트**: 데이터베이스의 내용을 조작하고 관리합니다.

> 💡 **DCL (데이터 제어 언어)**:

> - **목적**: DCL은 데이터베이스에 대한 액세스를 제어하는 데 사용됩니다.
> - **동작**: GRANT, REVOKE 등의 명령을 포함합니다.
> - **예시**: 사용자에게 권한 부여, 사용자의 권한 취소 등.
> - **주요 포인트**: 데이터베이스에 대한 액세스 권한을 관리하고 제어합니다.

### 내부 스키마 (Internal Schema)

- 저장 스키마(Storage Schema)와 같다
- 물리적 저장장치의 입장에서 본 데이터베이스 구조다
- 실제로 데이터베이스에 저장될 레코드의 물리적은 구조를 정의하고, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다
- 시스템 프로그래머/설계자가 보는 관점의 스키마다

# `3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해주세요.`

**트랜잭션**

- 데이터베이스의 상태를 변화시키기 위해 수행되는 작업의 단위

**ACID**

- Atomicity 원자성 : 트랜잭션이 데이터베이스에 모두 반영되거나, 전혀 반영되지 않아야 한다.
- Consistency 일관성 : 트랜잭션이 진행되는 동안에 데이터베이스가 변경되더라도 처음에 참조한 데이터베이스로 트랜잭션을 수행해야 한다.
    - 업데이트된 데이터베이스는 사용하지 않는다.
- Islation 고립성 : 둘 이상의 트랜잭션이 동시에 실행되고 있는 경우, 각각 다른 트랜잭션의 연산에 끼어들 수 없다.
    - 이 트랜잭션이 완료될 때까지 다른 트랜잭션은 이 트랜잭션의 결과를 참조할 수 없다.
- Durability 지속성 : 트랜잭션이 성공적으로 완료되었을 때, 영구적으로 반영 되어야한다.

### `1) ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?`

- **Redo**는 이미 커밋한 트랜잭션의 수정을 재반영하는 복구 작업이다.
- 정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하는 **FORCE**버퍼관리 정책과 수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는**¬FORCE**정책 중 채택할 수 있다.
- Force 정책을 따르면 트랜잭션이 커밋되면 디스크 상의 데이터베이스에 변경사항이 반영되기 때문에 REDO 복구작업이 필요없지만, ¬FORCE 정책을 따르면 커밋한 내용이 디스크 상의 데이터베이스에 반영되지
  않았을 수도 있기 때문에 반드시 REDO 복구가 필요하다.
- 거의 모든 DBMS가 ¬FORCE 정책을 채택한다.

### `2) 트랜잭션 사용 경험? 어떤 경우에 사용 가능?`

- 하나의 엔티티에 여러 작업이 동시에 수행될 가능성이 있을 때 사용하는 것이 좋다.
- 작업이 한번에 반영되야되는 것을 보장해야 할 때
    - EX 은행 입출금

### `3) 읽기에는 트랜잭션을 걸지 않아도 될까요?`

읽기 연산만 일어나면 데이터의 변경이 일어나지 않기 때문에 동시에 읽어도 문제가 생기지 않는다.

1. Dirty Read
    1. 수정 중이고 커밋되지 않은 데이터를 다른 트랜잭션에서 읽게 되어 일관성에 어긋난다.
2. Non-Repetable Read
    1. 한 트랜잭션 내에서 같은 쿼리를 두번 수행할 때, 그 사이에서 다른 트랜잭션이 수정 또는 삭제해서 둘의 결과가 다르게 나타나는 현상이 발생 할 수 있다.
3. Phantom Read
    1. 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 현상

# `트랜잭션 격리 레벨에 대해서 설명해주세요.`

1. `Read Uncommitted` 레벨 0

- **아예 격리가 되지 않는 레벨**
- 트랜잭션에 처리 중이거나, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있는 격리 수준이라, DB 일관성을 유지할 수 없다.
- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는다.
- 이 격리수준에서는 Dirty Read, Non-repeatable Read, Phantom Read 현상이 발생할 수 있다.

1. `Read Committed` 레벨 1

- **커밋된 데이터만 읽기 허용**
- 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어서 대기한다.
- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸린다.
- 이 격리 수준에서는 Non-Repeatable Read, Phantom Read 현상이 발생할 수 있다.

1. `Repeatable Read`

- **선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때 까지 후행 트랜잭션이 갱신하거나 삭제하는 것을 불허**
- SELECT 문장이 사용되는 모든 데이터에 Shared Lock이 걸린다.
- Phantom Read 현상이 발생할 수 있다.

1. `Serializable`

- **선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신하거나 삭제하는 것을 불허하는것 뿐 아니라, 새로운 레코드를 삽입하는 것도 막아 완벽한 읽기 일관성을 보장**
- 트랜잭션이 완료될 때까지 SELECT문이 사용되는 모든 데이터에 Shared Lock이 걸린다.
- 일반적으로 레벨이 높아질수록 트랜잭션 간 고립 정도가 높아지는 동시에 성능이 저하된다.

### `1) 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?`

아니요, Read Uncommited 레벨과 같은 경우 거의 필요 없음, Repeatable Read은 오라클의 경우 다중 버전 기반의 읽기 일관성 매커니즘에 의해 Serializable이 효과적으로 지원되어
포함되지 않았다.

> 다중 버전 읽기 일관성
> - 데이터를 읽을 때 록에 의해 록이 풀리기를 기다리는 것이 아니라 이전 버전의 정보를 읽음으로서 쓰기 트랜잭션이 읽기 작업을 막지 않는다.

- 오라클
    - 오라클은 Read Committed 레벨1을 사용한다.
    - Read Committed락을 사용하지 않고 쿼리 시작 시점의 Undo 데이터를 제공하는 방식으로 구현한다.
- MySQL
    - InnoDB 스토리지 엔진은 Repeatable Read 레벨2를 사용한다.

### `2) Undo 영역과 Redo 영역에 대해 설명해 주세요.`

- **Redo Log**
    - DB 장애시 복구에 사용되는 로그
    - Buffer Pool에 저장되어 있던 데이터의 유실을 방지하기 위해 사용된다.
        - **Buffer Pool**: InnoDB 엔진이 테이블 캐싱 및 인덱스 데이터 캐싱을 위해 이용하는 메모리 공간. 버퍼풀의 메모리 공간이 클수록 캐싱되는 데이터가 늘어나서 디스크에 접근하는 횟수가
          줄어들고, DB 성능 향상으로 이어진다. 하지만 버퍼풀은 메모리 공간이라서 MySQL 장애 발생시 안의 내용은 사라지고, 장애가 복구되더라도 데이터는 복구될 수 없다.
    - 데이터 변경시에 모든 것을 기록한다.
- **Undo Log**
    - 실행 취소 로그 레코드의 집합으로, 트랜잭션 실행 후 롤백시 이전 데이터로 복구할 수 있도록 해놓은 영역
    - 변경되기 전의 데이터와 PK값을 저장.

### `3) 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?`

- 데이터베이스에 대해 삽입, 추출, 업데이트 및 삭제하는 데 사용하는 기본 소프트웨어 컴포넌트
- MySQL은 크게**서버 엔진**과**스토리지 엔진**두가지 구조로 구성되어 있다.
    - 서버 엔진은 클라이언트의 쿼리 요청을 받아 쿼리 파싱과 스토리지 엔진 데이터를 요청하는 작업을 수행한다.
    - 스토리지 엔진은 물리적 저장장치에서 데이터를 읽어온다.

# `11. DB Locking에 대해 설명해 주세요.`

- DB Locking은 동시성 제어와 연관이 있다.
- 동시성 제어는 DBMS가 다수의 사용자 사이에서 동시에 작용하는 다중 트랜잭션의 상호 간섭 작용에서 DB를 보호한다.
- 동시성을 허용하면 일관성이 낮아지는 편이다.
- 다수 사용자의 동시 접속을 위해 DBMS는 Lock 기능과 SET Transatcion 명령어로 동시성을 제어한다.
- 동시성을 제어하는 방법에는 낙관적 동시성 제어와 비관적 동시성 제어가 있다.

### DB Locking 종류

비관적 동시성 제어를 위한 대표적인 방법은 Lock이다. 락은 트랜잭션 처리의 순차성을 보장한다.

- 공유락 (Share Lock) : 읽기 잠금
    - 공유락끼리는 동시에 접근이 가능하다.
    - 여러 사용자가 동시에 하나의 데이터를 읽을 수 있다.
    - 공유락이 설정된 데이터에 배타락을 걸 수는 없다.
- 배타락 (Exclusive Lock) : 쓰기 잠금
    - 데이터를 변경하고자 할 때 사용한다.
    - 락이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없다.
    - 해당 락은 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 락을 설정할 수 없다.

### 락 사용시 유의사항

> 블로킹: 락(배타-배타, 배타-공유)의 경합이 발생하여 특정 트랜잭션이 작업을 진행하지 못하고 멈춘 상태
>

1. 한 트랜잭션의 길이가 너무 길면 경합이 발생할 확률이 올라간다
2. 처음 설계부터 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 주의한다
3. 트랜잭션 격리성 수준을 불필요하게 상향 조정하지 않는다
4. 쿼리를 오랜시간 잡아두지 않도록 적절한 튜닝을 진행한다

데드락이 발생할 수 있으니 유의하자

### `1) Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.`

- `낙관적 동시성 제어 (Optimistic Concurrency Controll)`
    - 낙관적 락은 일반적으로 충돌이 발생할 것으로 예상하지 않는 상황에서 사용됩니다.
    - 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정해서 데이터를 **읽는 시점에 락을 걸지 않는다.**
    - 대신에 수정 시점에 값이 변경 됐는지를 검사한다.
    - 주로 낙관적 락은 버전 관리나 변경 추적을 통해 구현됩니다. 예를 들어, 데이터의 버전 번호를 사용하여 동시성 충돌을 감지할 수 있습니다.
- `비관적 동시성 제어 (Pessimistic Concurrency Control)`
    - 비관적 락은 충돌이 발생할 것으로 예상되는 상황에서 사용된다.
    - 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정해서 데이터를 **읽는 시점에 락**을 걸고, 트랜잭션이 완료될 때까지 락을 유지한다.
    - 락을 통해 업데이트를 제어하기 때문에 데이터 정합성이 보장됨.
    - Select 시점에 락을 거는 비관적 동시성 제어는 시스템의 동시성을 심각하게 저하 시킬 수 있어서 wait/nowait 옵션과 함께 사용해야 한다.

###
`2) 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?`

- 데드락 탐지 및 해결
    - DB 시스템은 데드락을 탐지하고 해결하기 위한 메커니즘을 제공한다.
    - 데이터베이스 시스템은 주기적으로 데드락을 탐지하고 해결함으로써 이를 방지할 수 있습니다. 이를 통해 락이 영구적으로 해제되지 않는 상황을 방지할 수 있습니다.
- 타임아웃 설정
    - 특정 시간동안 트랜잭션이 락을 획득하지 못한 경우, 락이 자동으로 해제되어 데드락 상황 방지할 수 있다.
- MVCC
    - 데이터베이스 시스템에서 동시성 제어를 위해 사용되는 기술입니다.
        - MVCC에서 데이터에 접근하는 사용자는 접근한 시점에 데이터베이스의 스냅샷을 읽는다.
        - 이 스냅샷 데이터에 대한 변경은 다중 버전 상태로 유지되어 커밋 전까지는 스냅샷을 undo 영역에 유지하고 있다.
        - 그래서 다른 트랜잭션은 undo 영역을 참조하여 데이터를 사용한다.
    - MVCC는 동시에 여러 트랜잭션이 데이터에 접근할 때 발생할 수 있는 문제를 해결하기 위해 도입되었습니다.
    - 주로 대부분의 현대적인 관계형 데이터베이스 시스템에서 사용됩니다.
    - MVCC는 다중 버전을 사용하여 동시성을 제어하는 방식으로, 락을 최소화하고 동시성을 향상 시킨다.
    - MVCC 사용시 락을 걸지 않고도 데이터에 접근할 수 있으며, 이는 락이 비정상 종료로 인해 영구적으로 유지되는 문제를 해결할 수 있다.

# `5. 인덱스란? 언제 사용?`

- 추가적인 쓰기 작업과 저장 공간을 활용해 DB 테이블의 탐색 속도를 향상 시키기 위한 자료구조
- 컬럼에 대해 색인을 부여해 빠르게 탐색이 가능하다.
    - 데이터 조회/수정/삭제의 성능이 향상된다.
- 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
- **규모가 큰 테이블, 수정이 적은 컬럼, 조회가 잦은 컬럼, 데이터 중복이 낮은 컬럼이 효율적**

### `1) 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?`

- 인덱스는 항상 정렬된 상태로 유지해야 하기 때문에 수정을 할 경우 인덱스를 추가하거나 인덱스를 사용하지 않는다는 처리 등의 추가적인 작업이 필요하기 때문에 성능이 낮아진다.
    - 인덱스를 수정할 때마다 해당 인덱스를 **재구성해야** 하므로 **오버헤드가** 발생합니다.
- `INSERT` : 테이블에는 입력 순서대로 저장되지만, 인덱스 테이블에는 저렬하여 저장하기 때문에 성능 저하가 발생한다.
- `DELETE` : 테이블에서만 삭제되고 인덱스 테이블에는 남아 있어서 쿼리 수행 속도가 저하 된다.
- `UPDATE` : 인덱스에는 UPDATE가 없어서 DELETE, INSERT 두 작업을수행하여 부하가 발생한다.
- 수정이 잦으면 실제 데이터보다 인덱스의 크기가 너무 커져 부하가 발생

### `2) 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?`

- 인덱스를 사용하지 않는다고 선택한 값은 위 정책을 그대로 따르지는 않습니다.
- 수정이 잦은 테이블에서 인덱스를 사용하지 않는 것은 성능 이슈를 방지하기 위한 것이며, 이는 선택적인 결정입니다.
- 따라서 다른 성능 최적화 방법을 고려하고 적절한 경우 인덱스를 사용하지 않는 것이 더 나을 수 있습니다.
- 개발자는 특정 상황에 따라 최적의 결정을 내리고, 이를 효과적으로 관리해야 합니다.

### `3) ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.`

**`ORDER BY`**

- 인덱스 O : 인덱스가 있다는 것은 인덱스 컬럼을 기준으로 정렬되어 있다는 것이므로, 별도의 정렬을 위한 처리가 필요없다.
- 인덱스 X : **Filesort** 방식으로, 레코드를 읽어온 후 MySQL 서버에서 SortBuffer 라는 메모리 공간을 활용해 정렬한다.
    - Sort Buffer의 크기는 가변적으로 증가하고 최대 사이즈는 시스템 변수`sort_buffer_size`로 설정할 수 있다.

**`GROUP BY`**

- 인덱스 O : 인덱스가 있다는 것은 인덱스 컬럼을 기준으로 정렬되어 있다는 것이므로, 별도의 정렬을 위한 처리가 필요없다.
- 인덱스 X : 인덱스를 사용할 수 없을 때는 **임시 테이블**을 사용한다.

  > 임시 테이블을 사용하여 처리될 때는 Extra 컬럼에 "Using temporary" 메시지가 나타난다

### `4) 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?`

- 일반적으로 PK가 자동으로 인덱스 적용이 되지만, PK ≠ 인덱스
- PK는 개념적인 값으로 레코드의 유일성을 보장하지만 물리적으로 **저장 X**
- 반면 인덱스는 레코드의 유일성을 보장하지 않고, 단지 탐색을 빠르게 해주는 역할이다.
    - 그리고 별도의 디스크 공간에 저장된다.

### `5) 그렇다면 외래키는요?`

- DB에 따라 다름, innoDB인경우 생성

### `6) 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?`

- 인덱스는 데이터의**논리적 구조**를 나타내는 구조이며, 데이터 자체의**물리적 저장 방식**을 결정하지는 않습니다.
- 일반적으로 DBMS는 다음과 같은 방식 중 하나를 사용하여 데이터를 저장합니다.
    - **힙 (Heap):**데이터가 추가되는 순서대로 저장됩니다. 삽입 작업은 빠르지만, 특정 값을 찾는 데 시간이 오래 걸릴 수 있습니다.
    - **B-트리 (B-Tree):**데이터가 균형 잡힌 트리 구조로 저장됩니다. 삽입, 삭제, 검색 작업 모두 효율적으로 수행할 수 있습니다.
    - **해시 테이블 (Hash Table):**데이터의 특정 값을 기반으로 해시 함수를 사용하여 저장 위치를 결정합니다. 특정 값을 빠르게 찾는 데 효율적입니다.

### `7) 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?`

- MongoDB
    - 기본적으로 B-트리 인덱스를 사용하지만, 풀 텍스트 인덱스, 지리적 인덱스 등 다양한 유형의 인덱스를 제공
- Redis
    - 레디스의 내부 인덱싱 기능은 주로 키에 대한 검색에 사용
    - 레디스는 키를 사용하여 데이터를 조회하므로, 키의 빠른 검색을 위해 내부적으로 해시(Hash) 테이블을 사용합니다.
    - 이 해시 테이블은 O(1)의 시간 복잡도로 키에 대한 조회를 수행할 수 있도록 합니다.
- RDB와 SQL 인덱스 차이
    - RDB는 B-트리와 같은 구조를 사용하여 인덱스를 관리하며, NoSQL은 데이터베이스 종류에 따라 다양한 인덱스 구조를 사용합니다.

# `10. B-Tree와 B+Tree에 대해 설명해 주세요.`

### B-Tree (Balanced-Tree)

- 균형 트리이다.
- 루트로 부터 리프까지의 **거리가 일정한** 트리 구조라는 뜻
- 일반적트리를 사용했을 때 발생할 수 있는 편향 트리를 방지하기 위해 나옴
- O(logN)을 보장
- 장점 : 데이터 검색의 속도가 빠르다
- 단점 : 트리 노드가 수정되어야 하면 재정렬이 필요
- **루트(root) 노드**
    - 최상단에 위치한 노드
- **리프(leaf) 노드**
    - 자식이 없는 최하단에 위치한 노드
- **내부(internal) 노드**
    - 루트노드와 리프노드를 제외한 모든 노드
- 검색 과정
    1. 루트 노드부터 탐색
    2. 노드의 key를 순회하여 목표 데이터가 존재하면 탐색 종료
    3. 목표 데이터가 존재하지 않으면 어떤 이웃한 두 key 사이에 목표 데이터가 들어가는 경우 사이의 포인터를 통해 자식노드로 내려간다.
    4. 리프 노드까지 2~3번 과정을 반복한다.
- key 삽입 과정
    1. 빈 트리인 경우 루트 노드를 만들어 삽입한다. 루트 노드가 찬 경우에는 노드를 분할해 리프 노드를 생성한다
    2. K가 들어갈 리프 노드를 검색 과정과 동일하게 탐색한다
    3. 해당 리프 노드에 자리가 남으면 정렬을 유지하도록 알맞은 위치에 삽입하고, 차있으면 K를 삽입한 후 해당 노드를 분할한다
    4. 노드가 분할되는 경우면 노드의 중앙값을 기준으로 분할한다. 중앙값은 부모 노드로 합쳐지거나 새로운 노드로 생성된다. 중앙값을 기준으로 왼쪽 키는 왼쪽 자식, 오른쪽 키는 오른쪽 자식으로 생성된다.

### B+Tree

- 모든 리프 노드들은**링크드 리스트**형태로 이어져있다.
- **실제 데이터는 리프 노드에만 저장된다.**
    - 내부 노드들은 단지 키만 가지고 있고 올바른 리프 노드로 연결해 주는 라우팅 기능을 한다.
- B+Tree 는**리프 노드를 제외하고 값을 담아두지 않기 때문에 하나의 블록에 더많은 Key 들을 담아 둘 수 있다**는 장점이 있습니다.
    - 이는 곧, 트리의 높이가 낮아짐을 나타냅니다.

### `1) 그렇다면, B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 그렇지 않다면 어떤 단점이 있을까요?`

- B-tree에서는 자주 access 되는 노드를 루트 노드에 가깝게 배치하여 루트 노드에서 가까울 경우 브랜치 노드에도 데이터가 존재하기 때문에 B+Tree보다 빠르다.
- B+Tree는 리프 노드에만 데이터가 존재해서 이런 구현이 불가능 하다.
- B-Tree는 키의 중복이 존재하지 않는 반면에, B+Tree는 리프 노드에 모든 데이터가 존재해서 키 중복이 가능하다.

### `2) DB에서 RBT를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유가 있을까요?`

### Red-Black Tree (RBT)

RBT는 자가 균형 이진 탐색 트리로 다음과 같은 조건을 만족해야 한다

1. 모든 노드는 빨간색 혹은 검은색이다
2. 루트 노드는 검은색이다
3. 모든 리프 노드는 검은색이다
4. 빨간 노드의 자식은 검은색이다 (=빨간 노드가 연속적으로 발생할 수 없다)
5. 모든 리프 노드에서 black depth는 같다 (리프 노드에서 루트 노드까지의 경로에서 만나는 검은 노드의 개수가 같다)

### DB에서 RBT를 사용하지 않는 이유

RBT는**이진**탐색 트리라서 각 노드의 자식 노드가 최대 2개로 유연성이 적다.

Red-Black 특성으로 인한 조건이 세부적이라서 재구성이 흔한데, 데이터베이스에서 이 자료구조를 사용하면 부하가 올 가능성이 크다.

### DB에서 B-Tree를 사용하는 이유

1. **항상 정렬된 상태**로 특정값보다 크고 작은 부등호 연산에 문제 없다
2. 참조 포인트가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능하다
3. 데이터 탐색/저장/수정/삭제에도 항상 O(logN)의 시간 복잡도를 가진다

### `3)오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까요? B-Tree/B+Tree의 구조를 기반으로 설명해 주세요.`

1. **B-트리**

- B-트리에서는 각 노드의 키를 오름차순으로 유지합니다.
- 따라서 내림차순으로 정렬된 인덱스를 생성하려면 키의 순서를 뒤집어야 합니다.
- 이는 새로운 내림차순 인덱스를 만들 때 추가적인 작업으로, 새로운 키를 정렬된 순서에 맞게 삽입하는 과정이 필요합니다.
- 이 과정은 오름차순 인덱스를 생성하는 과정과 유사하지만, 키의 순서를 반대로 유지해야 합니다.

1. **B+트리**
    - B+트리에서도 내림차순으로 정렬된 인덱스를 생성하기 위해서는 유사한 과정이 필요합니다.
    - 각 노드의 키는 오름차순으로 유지되지만, **리프 노드에만 데이터가 저장**되므로 리프 노드에서의 키의 순서를 뒤집어야 합니다.
    - 따라서 새로운 내림차순 인덱스를 만들 때는 리프 노드에서 키의 순서를 반대로 유지하도록 새로운 키를 삽입해야 합니다.

# **15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.**

**`Table Full Scan`**

- 테이블 전체를 순차적으로 스캔하여 조건에 맞는 데이터를 찾는 것
- 인덱스를 사용하지 않고, 테이블의 모든 행을 읽어 조건에 맞는 행을 찾는다.
- 작은 테이블에는 효과적일 수 있지만, 대용량 테이블에 대해서는 많은 자원과 시간이 소요됨
- 특히 조건에 맞는 행이 적은 경우에는 불필요 행까지 모드 읽어야 하므로 효율성 떨어짐

**`Index Scan`**

> **Loose Index Scan**
>
> - 인덱스의 레코드를 건너 뛰면서 필요한 부분만 읽어서 가져온다.
> - 별도의 임시 테이블이 필요하지 않고, 인덱스의 유니크한 값의 수가 적을수록 성능 향상
>
> **Tight Index Scan**
>
> - 드라이빙 테이블(Driving) : Join문에서 먼저 액세스 되어 Access Path를 주도하는 테이블
> - 드리븐 테이블 (Driven) : 나중에 액세스되는 테이블

쿼리 조건에 따라 full index scan 또는 index range scan을 사용한다

`Index Range Scan`

- 인덱스를 수직 탐색 후 필요한 범위까지만 탐색하는 방식
- **각 리프 블록은 다음 리프 블록의 정보를 담고있어 다시 브랜치부터 읽을 필요 없이 다음 데이터를 바로 읽을 수 있다.**

### `1) 가끔은 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?`

- 인덱스의 효율성 :
    - 인덱스를 사용하는 것보다 Full Scan이 더 효율이 좋을 때
- 인덱스 선택 기준 :
    - 쿼리 옵티마이저가 인덱스를 선택할 때, 인덱스의 선택 기준이 쿼리의 필터링 정도에 따라 다를 수 있다.
    - 즉 쿼리에 사용된 조건이나 필터링 조건이 인덱스의 선택 여부에 영향을 줄 수 있다.

### `2) 쿼리 작성 방식에 따른 인덱스 미적용 예시가 있나요`

- WHERE 절에 인덱스 컬럼을 사용하지 않은 경우 : 쿼리 조건에 인덱스 컬럼이 포함되지 않으면 쿼리 최적화기는 인덱스 사용을 고려하지 않습니다.
- LIKE 연산자를 사용한 경우 : LIKE 연산자는 인덱스를 사용할 수 없는 경우가 많습니다.
- ORDER BY 절에 인덱스 컬럼을 사용하지 않은 경우 : ORDER BY 절에 지정된 컬럼이 인덱스에 포함되지 않으면 쿼리 최적화기는 Table Full Scan 방식을 선택할 수 있습니다.
