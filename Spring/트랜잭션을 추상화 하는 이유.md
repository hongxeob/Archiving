## 트랜잭션을 추상화하지 않는다면?

1. 트랜잭션을 사용하는 코드는 데이터 접근 기술마다 다르다.
2. 따라서 데이터 접근 기술이 바뀌면 서비스 계층의 코드도 바뀐다.
3. 이것은 OCP 원칙을 위반한다.

## 스프링에서 트랜잭션 추상화를 하는 이유?
- 데이터베이스 독립성 제공
  - 트랜잭션 추상화를 사용하면 데이터베이스와 관련된 세부 사항을 숨길 수 있다.
  - 이렇게 하면 애플리케이션이 다양한 데이터베이스와 호환되도록 만들 수 있으며, 데이터베이스 변경 시에도 코드 변경이 최소화된다.
- 트랜잭션 관리의 단순화
  - 트랜잭션 추상화는 트랜잭션의 시작, 커밋, 롤백 등의 작업을 추상화하여 애플리케이션이 직접 처리하는 것보다 더 쉽게 관리할 수 있다.
- 다양한 트랜잭션 기능 제공
  - 이러한 기능에는 읽기 전용 트랜잭션, 분산 트랜잭션, 중첩 트랜잭션 등이 포함됩니다. 이러한 트랜잭션 기능은 애플리케이션에서 트랜잭션을 다룰 때 유용하게 사용된다.
- 테스트 용이성
  - 트랜잭션 추상화를 사용하면 단위 테스트와 통합 테스트를 쉽게 수행할 수 있다. 
  - 테스트 환경에서는 데이터베이스를 초기화하고 테스트가 끝나면 롤백하므로, 테스트 중에 발생한 변경 내용이 실제 데이터베이스에 적용되지 않는다.

따라서, 스프링에서는 트랜잭션 추상화를 통해 애플리케이션에서 트랜잭션 관리를 단순화하고, 다양한 트랜잭션 기능을 제공하며, 데이터베이스 독립성과 테스트 용이성 등의 이점을 제공한다.

## 쉽게 생각하면..
- 트랜잭션은 단순하다. 트랜잭션을 시작하고 비즈니스 로직이 끝난 후 커밋이나 롤백을 수행하면 된다.
- 따라서 이 인터페이스를 기반으로 각 데이터 접근 기술에 적합한 구현체를 만들면 된다.

```java
public interface TxManager {
    begin();
    commit();
    rollback();
}
```

![image](https://user-images.githubusercontent.com/97447334/229276348-2692e15c-6b97-4f46-882f-051fae7fb16a.png)

- 서비스는 이제 특정 트랜잭션 기술에 직접 의존하는 것이 아니라 TxManager라는 추상화된 인터페이스에 의존한다.
- 실제 구현체는 DI를 통해 주입한다.
- 클라이언트인 서비스는 TxManager에 의존하고 DI를 사용함으로써 OCP 원칙을 지키게 되었다.

스프링에서는 이미 이런 고민을 다 해두었고, 스프링이 제공하는 트랜잭션 추상화 기술을 사용하면 된다.(`PlatformTransactionManager`)