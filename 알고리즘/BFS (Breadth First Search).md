# BFS (Breadth-first Search)

BFS는 너비 우선 탐색이라고 부르기도 한다.<br>
기본적으로 그래프 탐색에 사용되며, 가까운 노드부터 우선적으로 탐색하는 알고리즘이다.<br>
BFS는 큐(Queue) 자료구조를 사용해서 구현할 수 있다.

<img width="608" alt="image" src="https://user-images.githubusercontent.com/97447334/236400090-8aec5cdb-1b6f-4411-82a0-d0360d47c168.png">

위와 같은 그래프가 존재하고 노드의 탐색은 1번부터 시작한다고 가정하면
1. 큐에 1번 노드를 넣고 방문 처리(boolean)를 한다.
    1. 여기서 방문처리라는 것은 내가 해당 노드에 방문했음을 기록하는 것
2. 1번 노드와 가까운 노드를 큐에 넣고 방문 처리한다. (2, 3, 8번 노드)
    1. 순서는 상관없다
3. 큐에서 노드를 하나 꺼낸다.
    1. 연결된 노드가 없으면 3번으로 다시 돌아간다.
4. 연결된 노드가 있고 방문하지 않았으면 큐에 넣고 방문처리 후 3번으로 돌아간다.
5. 연결된 노드가 있지만 방문을 이미 한 경우에도 3번으로 돌아간다.
6. 3 ~ 6 과정을 큐가 빌 때까지 반복하며 큐가 비었으면 종료한다.

이러한 순서로 BFS를 진행하면 그래프에서 탐색 순서는 다음과 같다<br>
`1 → 2→ 3→ 6 → 8 → 5→ 4 → 7`
````java
public class BFS {
    public static void main(String[] args) {
        /**
         * 그래프를 2차원 배열로 표현
         * 배열의 인덱스를 노드와 매칭시켜서 사용하기 위해 인덱스 0은 아무것도 저장하지 않는다
         * 1번 인덱스는 1번 노드를 뜻하고 노드의 배열의 값은 연결된 노드들이다.
         * */
        int[][] graph = {{}, {2, 3, 8}, {1, 6, 8}, {1, 5}, {5, 7}, {3, 4, 7}, {2}, {4, 5}, {1, 2}};

        /**
         * 방묹 처리를 위한 boolean 배열 선언*/
        boolean[] visited = new boolean[9];
        System.out.println(bfs(1, graph, visited));
    }

    private static String bfs(int start, int[][] graph, boolean[] visited) {
        //탐색 순서를 출력하기 위한 용도
        StringBuilder sb = new StringBuilder();
        //BFS에 사용할 큐를 생성
        Queue<Integer> q = new LinkedList<Integer>();

        //큐에 BFS를 시작할 노드 번호를 넣어 준다.
        q.offer(start);
        //시작 노드 방문처리
        visited[start] = true;

        //큐가 빌 때까지 반복
        while (!q.isEmpty()) {
            int nodeIndex = q.poll();
            sb.append(nodeIndex + " -> ");
            //큐에서 꺼낸 노드와 연결된 노드들 체크
            for (int i = 0; i < graph[nodeIndex].length; i++) {
                int temp = graph[nodeIndex][i];
                //방문하지 않았으면 방문 처리 후 큐에 넣기
                if (!visited[temp]) {
                    visited[temp] = true;
                    q.offer(temp);
                }
            }
        }
        //탐색 순서 리턴
        return sb.toString();
        
        // 1 -> 2 -> 3 -> 8 -> 6 -> 5 -> 4 -> 7

    }
}
````
**※ DFS와 BFS의 시간 복잡도**

두 방식 모두 조건 내의 모든 노드를 검색한다는 점에서 시간 복잡도는 동일하지만 일반적으로 DFS를 재귀 함수로 구현한다는 점에서 DFS보다 BFS가 조금 더 빠르게 동작한다고 기억하면 된다.

> N이 노드의 개수, E가 간선의 개수일 때
> 
> 
> **인접 리스트: O(N + E)**
> 
> **인접 행렬: O(N^2)**
> 

### **문제의 특징 별 DFS / BFS 활용**

- **1. 그래프의 모든 정점을 방문하는 것이 주요한 문제**
  - 단순히 모든 정점을 방문하는 것이 중요한 문제의 경우 DFS, BFS 두 가지 방법 중 어느 것을 사용해도 상관이 없다.
- **2. 경로의 특징을 저장해둬야 하는 문제**
  - 예를 들어 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안 된다는 문제 등, 각각의 경로마다 특징을 저장해둬야 할 때는 DFS를 사용한다. (BFS는 경로의 특징을 가지지 못한다)
- **3. 최단거리를 구하는 문제**
  - 미로 찾기 등 최단 거리를 구해야 할 경우, BFS가 유리하다.
  - 왜냐하면 DFS로 경로를 검색할 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있지만, BFS는 현재 노드부터 가까운 곳부터 찾기 때문에 경로 탐색 시 먼저 찾아지는 해답이 곧 최단거리이기 때문이다.

이외에도 검색 대상 그래프가 정말 크다면 DFS를 고려하고 검색 대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 BFS를 고려하는 등으로 더 생각해볼 수 있다.