# DFS (Depth First Search)

- 깊이 우선 탐색이라고도 한다.
- 한 노드에서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식
- 검색 속도 자체는 `BFS`에 비해 느리지만 조금 더 간단하다.
- 스택 or 재귀함수로 구현한다.

<img width="617" alt="image" src="https://user-images.githubusercontent.com/97447334/237000905-e09e940e-36e4-4429-90f8-35c334219e20.png">

```java
public class DFS {
    /**
     * 방문 처리에 사용할 배열 선언
     */
    static boolean[] visited = new boolean[9];
    /**
     * 그래프의 연결 상태를 2차원 배열로 표현
     * 인덱스가 각각의 노드번호가 될 수 있게 0번 인덱스는 아무것도 없는 상태라고 생각
     */
    static int[][] graph = {{}, {2, 3, 8}, {1, 6, 8}, {1, 5}, {5, 7}, {3, 4, 7}, {2}, {4, 5}, {1, 2}};

    public static void main(String[] args) {
        dfs(1);
    }

    private static void dfs(int nodeIndex) {
        //방문 처리
        visited[nodeIndex] = true;

        //방문 노드 출력
        System.out.print(nodeIndex + " -> ");

        //방문한 노드에 인접한 노드 찾기
        for (int node : graph[nodeIndex]) {
            //인접한 노드가 방문한 적이 없다면 DFS 수행
            if (!visited[node]) {
                dfs(node);
            }
        }
    }
}

```

## DFS와 BFS의 시간 복잡도

두 방식 모두 조건 내의 모든 노드를 검색한다는 점에서 시간 복잡도는 동일하지만 일반적으로 `DFS`를 재귀 함수로 구현한다는 점에서 `DFS`보다 `BFS`가 조금 더 빠르게 동작한다고 기억하면 된다.

> N이 노드의 개수, E가 간선의 개수일 때
> 
> 
> **인접 리스트: O(N + E)**
> 
> **인접 행렬: O(N^2)**
> 

## 문제의 특징 별 DFS / BFS 활용

- **1. 그래프의 모든 정점을 방문하는 것이 주요한 문제**
  - 단순히 모든 정점을 방문하는 것이 중요한 문제의 경우 DFS, BFS 두 가지 방법 중 어느 것을 사용해도 상관이 없다.
- **2. 경로의 특징을 저장해둬야 하는 문제**
  - 예를 들어 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안 된다는 문제 등, 각각의 경로마다 특징을 저장해둬야 할 때는 DFS를 사용한다. (BFS는 경로의 특징을 가지지 못한다)
- **3. 최단거리를 구하는 문제**
  - 미로 찾기 등 최단 거리를 구해야 할 경우, BFS가 유리하다.
  - 왜냐하면 DFS로 경로를 검색할 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있지만, BFS는 현재 노드부터 가까운 곳부터 찾기 때문에 경로 탐색 시 먼저 찾아지는 해답이 곧 최단거리이기 때문이다.

이외에도 검색 대상 그래프가 정말 크다면 DFS를 고려하고 검색 대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 BFS를 고려하는 등으로 더 생각해볼 수 있다.