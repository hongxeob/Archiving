## ALU가 받아 들이는 정보들!


> Tip : 결과값을 레지스터로 저장하는 이유는 CPU가 메모리에 접근하는 것보다 훨씬 빠르기 때문이다.

-   ALU는 결과값 뿐만 아니라 연산 결과에 대한 추가적인 정보를 내보내야 할 때가 있다.  
    \- 플래그는 추가적인 정보를 말한다(음수인지,양수인지,오버플로우 인지...)

## 제어장치가 받아 들이는 정보들!
-   **클럭 신호**를 받아들인다  
    \- 클럭이란 컴퓨터의 모든 부품을 일사분란하게 움직일 수 있게 하는 시간 단위
-   '해석해야 할 명령어'(**명령어 레지스터)**를 받아 들인다  
    \- CPU가 해석해야 할 명령어는 '명령어 레지스터'라는 특별 레지스터에 저장됨  
    \-> 해석 후에 제어 신호를 발생시켜 부품들에 수행해야 할 내용을 알려줌
-   플래그 레지스터 속 플래그 값을 받아들인다
-   시스템 버스,그 중에서 제어 버스로 전달된 제어 신호를 받아들인다.

## 💡 레지스터

-   프로그램 카운터 : 메모리에서 가져올 명령어의 주소(메모리에서 읽어 들일 명령어의 주소)
-   명령어 레지스터 : 해석할 명령어(방금 메모리에서 읽어 들인 명령어)
-   메모리 주소 레지스터 : 메모리의 주소
-   메모리 버퍼 레지스터: 메모리와 주고 받을 값
  - >Tip : 순서는 만약 메모리에 1000번지에 있는 값 1101을 가져오고싶다!  
      >  1. 프로그램 카운터에 1000(번지)이 저장 된다. -> 메모리에서 가져올 명령어가 1000번지에 있다  
      >  2. 1000번지를 읽어오기 위해서는 주소 버스로 1000번지를 내보내야 한다.-> 메모리 주소 레지스터에 1000이 저장  
      >  3. 메모리 읽기 제어 신호+ 메모리 주소 레지스터 값이 각각 제어 버스,주소 버스를 타고 메모리에 보내짐  
      >  4. 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달 됨  
      > 5. 제일 처음 동작한 프로그램 카운터는 다음 명령어 준비를 위해 카운트가 증가되어 1001번지로 세팅 -> 프로그램을 순차적으로 실행할 수 있는 원리  
      >  6. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동  
      >  7. 제어 장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킴
-   플래그 레지스터 : 연산 결과 또는 CPU 상태에 대한 부가적인 정보
-   범용 레지스터 : 다양하고 일반적인 상황에서 자유롭게 사용.
-   스택 포인터 : 주소 지정에 사용
-   베이스 레지스터 : 주소 지정에 사용

### 특정 레지스터를 이용한 주소 지정 방식1 : 스택 주소 지정 방식

-   **스택 주소 지정 방식** : 스택과 스택포인터를 이용한 주소 방식  
    \- 스택 포인터 : 스택의 꼭대기를 가리키는 레지스터 ( 스택이 어디까지 차 있는지에 대한 표시)
### 특정 레지스터를 이용한 주소 지정 방식2 : 변위 주소 지정 방식(2가지)

-   **변위 주소 지정 방식** : 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값(프로그램 카운터 or 베이스 레지스터)을 더하여 유효 주소 얻기  
    \- **상대 주소 지정 방식** : 오퍼랜드 필드의 값(변위)과 프로그램 카운터의 값을 더하여 유효 주소 얻기  
    \- **베이스 레지스터 주소 지정 방식** : 오퍼랜드 필드의 값(변위)과 베이스 레지스터의 값을 더하여 유효 주소 얻기  
    베이스 레지스터는 '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리'로서의 역할을 한다.  