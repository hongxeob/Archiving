# 트랜잭션과 무결성
## 1. 트랜잭션
>트랜잭션은 DB에서 하나의 논리적 기능을 수행하기 위한 연산 단위를 말한다<br>
>즉 여러 개의 쿼리들을 하나로 묶는 단위를 말한다

A->B로 돈을 보내려고 한다 이런 상황에서
- A의 통장 잔고를 조회하여, 보내려는 금액 이상이 존재하는지 확인한다
- A의 통장 잔고에서 보내려는 금액만큼 값을 뺀다
- B의 통장 잔고에는 받는 금액만큼을 더한다
위 세가지 과정 중 연결 불안정 등의 문제가 발생한다면?
- A의 통장에서 돈이 빠져나가고, B의 통장으로 입금되지 않는다
- A의 잔고를 조회하고 보내려는 금액만음을 빼려는 사이 A가 다른 곳에 돈을 쓴다. 그러면 남은 잔고는 보내려는 금액보다 적어지는데, 앞에서 확인할 때는 보내려는 금액 이상 있었으므로 통장 잔고에서 금액을 그대로 뺀다
트랜잭션은 위와 같은 경우가 발생하는 것을 방지하기 위해 존재하며, 트랜 잭션의 특징 4개를  ACID (Atomicity, Consistency, Isolation, Durability)라고 부른다

### 1) 원자성 (Atomicity)
- 트랜잭션 내의 내용들이 하나의 단위(atomic)로 묶여서, 전체가 수행되거나 전체가 수행되지 않아야 한다는 속성을 가리킨다 
- 위의 예시에서 A가 B에게 돈을 보내줄 때 일어나는 세 가지 연산이 모두 실행되거나, 모두 실행되지 않아야 하는 성질을 말한다
- 여기서 커밋과 롤백의 개념이 등장한다
- `commit` :
  - 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
  - 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말한다
- `rollback` :
  - 에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야 할 때 사용한다
  - 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)을 말한다
- DBMS는 commit과 rollback을 통해 트랜잭션의 원자성을 보장해 준다 
```java
@Service
public Class MemberService {
    ...
    @Transactional
    public HashMap<String, String> updateClassMember(Map<String, Object> param) throws Exception {
        ...
    }
}
```
Spring 프레임워크에서는 Service 계층에서 @Transactional이라는 어노테이션을 통해 메소드 내의 로직의 원자성을 보장한다
### 2) 일관성 (Consistency)
- 허용된 방식으로만 데이터를 변경해야하는 것을 의미한다
- DB에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야한다
### 3) 격리성 (Isolation)
- 각 트랜잭션의 수행은 독립적이어야 함을 의미한다
- 위의 예시 중, A의 금액을 조회하고 A로부터 금액을 빼오는 사이에 다른 트랜잭션이 수행되어서 A의 잔고값이 변했다면, 격리성을 해치는 일이다
- 작업이 수행되는 중 다른 작업이 끼어들지 못하도록 하는 개념이며, 격리 단계가 총 4가지 존재한다
  - Read Uncommitted
  - Read Committed
  - Repeatable Read
  - Serializable
  - 위로 갈수록 독시성이 강해지지만 격리성은 양해지고 아래로 갈수록 동시성은 약해지고 격리성은 강해진다
### 격리 수준에 따라 발생하는 현상
#### Phantom read, 팬텀 리드
한 트랜잭션 내에서 **동일한 쿼리**를 보냈을 때 해당 조회 결과가 다른 경우를 말합니다 

#### non-repeatable read, 반복 가능하지 않은 조회
한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우
예를 들어 
1. 현재 A의 잔고가 100원일 때, 
2. 은행원1이 A의 잔고를 조회했는데, 
3. 그 이후 은행원2가 그 값을 1원으로 변경해서 커밋하면 
4. 은행원1은 100원이 아닌 1원을 읽게됩니다.

#### Dirty read, 더티 리드 
한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 `커밋되지 않은` 행의 데이터를 읽을 수 있을 때 발생합니다. 

예를 들어
1. 은행원1이 A의 잔고를 100원에서 1원으로 수정했는데 아직 커밋을 하지 않았을 때,
2. 은행원2는 A의 잔고를 1원 이라고 조회함

### 격리 수준
|         수준         |내용|단점|
|:------------------:|-----|------|
|    SERIALIZABLE    |순차적으로 진행시키는 것|교착 상태가 일어날 확률이 높음|
|  REPEATABLE_READ   |행 수정은 불가능하지만 행 추가는 가능|이후에 추가된 행이 발견될 수 있음|
|  READ_COMMITTED  |커밋하지 않은 정보는 읽을 수 없음|동시에 접근 가능하여 다른 내용이 발견될 수 있음|
|  READ_UNCOMMITTED  |커밋되기 이전에 다른 트랜잭션에 노출됨|무결성이 유지되지 않을 수 있음|
### 4) 지속성 (Durability)
- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미한다
- DB에 시스템 장애가 발생해도, DBMS는 자체적으로 복구하는 능력을 가지고 있으며, 이를 통해 지속성을 만족한다
- 체크섬 : 중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
- 저널링 : 변경사항을 commit 하기전에 로깅하는 것
- 롤백
## 2.무결성
- 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다
- 무결성이 유지되어야 DB에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생긴다

### 무결성의 종류

|이름| 설명                                                              |
|-----|-----------------------------------------------------------------|
|개체 무결성| 기본키로 선택된 필드는 빈 값을 허용하지 않음                                       |
|참조 무결성| 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야함                        |
|고유 무결성| 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐           |
|NULL 무결성| 특정 속성 값에 NULL이 나올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건  |