# 👾 자바 고급1

![img.png](img/img.png)
- **메서드 영역** : 메서드 영역은 프로그램을 실행하는데 필요한 공통 데이터를 관리한다. 이영역은 프로그램의 모든 영역에서 공유한다.
  - 클래스 정보 : 클래스의 실행 코드 (바이트 코드), 필드, 메서드와 생성자 코드등 모든 실행 코드가 존재한다.
  - static 영역 : static 변수들을 보관한다.
  - 런타임 상수 풀 : 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관한다.
- **스택 영역(Stack Area)** : 자바 실행 시, 하나의 실행 스택이 생성된다. 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함한다.
  - 스택 프레임: 스택 영역에 쌓이는 네모 박스가 하나의 스택 프레임이다. 메서드를 호출할 때 마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거된다.
- **힙 영역(Heap Area)** : 객체(인스턴스)와 배열이 생성되는 영억이다. GC가 이루어지는 주요 영역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거된다.

> **참고**: 스탬 영역은 더 정확히는 각 스레드별로 하나의 실행 스택이 생성된다. 따라서 스레드 수 만큼 스택이 생성된다. 지금은 스레드를 1개만 사용하므로 스택도 하나이다. 이후 스레드를 추가할 것인데, 스러면 스택도 스레드 수 만큼 증가한다.


## Thread 상속 vs Runnable 구현
스레드 사용할 때는 `Thread`를 상속받는 방법보다 `Runnable` 인터페이스를 구현하는 방식을 주로 사용한다.<br>
두 방식 서로 장단점이 있지만, 스레드를 생성할 때는 `Thread`를 상속하는 방법보다 `Runnable`인터페이스를 구현하는 방식이 더 나은 선택이다.<br>

**Thread 클래스 상속 방식**
- 장점
  - 간단한 구현 : `Thread` 클래스를 상속받아 run() 메서드만 재정의하면 된다.
- 단점
  - 상속의 제한 : 자바는 단일 상속만 허용한다. 그래서 이미 다른 클래스를 상속받고 있는 경우 `Thread` 클래스를 상속 받을 수 없다.
  - 유연성 부족 : 인터페이스를 사용하는 방법에 비해 유연성이 떨어진다.

**Runnable 인터페이스 구현 방식**
- 장점
  - 상속의 자유로움 : `Runnable` **인터페이스** 방식은 다른 클래스를 상속받아도 문제없이 구현할 수 있다.
    - 코드의 분리 : 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
    - 여러 스레드가 동일한 `Runnable` 객체를 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.
- 단점
  - 코드가 약간 복잡해질 수 있다. `Runnable` 객체를 생성하고 이를 Thread에 전달하는 과정이 추가된다.

## 스레드의 상태

- `New (새로운 상태)` : 스레드가 생성되었으나 아직 시작되지 않은 상태.
- `Runnable (실행 가능 상태)` : 스레드가 실행 중이거나 실행될 준비가 된 상태.
- 일시 중지 상태들 : 스레드가 코드를 실행하지 않고 가만히 놀고 있는 상태.
  - `Blocked` (차단 상태) : 스레드가 동기화 락을 기다리는 상태.
  - `Waiting` (대기 상태) : 스레드가 무기한으로 다른 스레드의 작업을 기다리는 상태.
  - `Timed Waiting (시간 제한 대기 상태)` : 스레드가 일정 시간 동안 다른 스레드의 작업을 기다리는 상태.
- `Terminated (종료 상태)` : 스레드의 실행이 완료된 상태.

### New (새로운 상태)
- 스레드가 생성되고 아직 시작되지 않은 상태이다.
- 이 상태에서는 Thread 객체가 생성되지만, `start()` 메서드가 호출되지 않은 상태.
- 예 : `Thread thread = new Thread(runnable);` 

### Runnable (실행 가능 상태)
- 스레드가 실행될 준비가 된 상태이다. 이 상태에서 스레드는 실제로 CPU에서 실행될 수 있다.
- `start()` 메서드가 호출되면 스레드는 이 상태로 들어감
  - 예 : `thread.start();`
- 이 상태는 스레드가 실행될 준비가 되어 있음을 나타내며, 실제로 CPU에서 실행될 수 있는 상태이다. 그러나 Runnable 상태에 있는 모든 스레드가 동시에 실행되는 것은 아니다. 운영체제의 스케줄러가 각 스레드에 CPU 시간을 할당하여 실행하기 때문에, Runnable 상태에 있는 스레드는 스케줄러의 실행 대기열에 포함되어 있다가 차례로 CPU에서 실행된다.
- 참고로 OS 스케줄러의 실행 대기열에 있든, CPU에서 실제 실행되고 있든 모든 RUNNABLE 상태이다. 자바에서 둘을 구분해서 확인할 수는 없다.
- 보통 실행 상태라고 부름

### Blocked (차단 상태)
- 스레드가 다른 스레드에 의해 동기화 락을 얻기 위해 기다리는 상태이다.
- 예를 들어, `synchronized` 블록에 진입하기 위해 락을 얻어야 하는 경우 이 상태에 들어간다.
- 예: `synchronized (lock) { ... }` 코드 블록에 진입하려고 할 때, 다른 스레드가 이미 `lock` 의 락을 가지고 있는 경우.

### Waiting (대기 상태)
- 스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태이다.
- `wait()` , `join()` 메서드가 호출될 때 이 상태가 된다.
- 스레드는 다른 스레드가 `notify()` 또는 `notifyAll()` 메서드를 호출하거나, `join()` 이 완료될 때까지 기다린다.
- 예: `object.wait();`

### Timed Waiting (시간 제한 대기 상태)
- 스레드가 특정 시간 동안 다른 스레드의 작업이 완료되기를 기다리는 상태이다.
- `sleep(long millis)` , `wait(long timeout)` , `join(long millis)` 메서드가 호출될 때 이 상태가 된다.
- 주어진 시간이 경과하거나 다른 스레드가 해당 스레드를 깨우면 이 상태에서 벗어난다.
- 예: `Thread.sleep(1000);`

### Terminated (종료 상태)
- 스레드의 실행이 완료된 상태이다.
- 스레드가 정상적으로 종료되거나, 예외가 발생하여 종료된 경우 이 상태로 들어간다.
- **스레드는 한 번 종료되면 다시 시작할 수 없다.**

### 자바 스레드의 상태 전이 과정
1. **New → Runnable**: `start()` 메서드를 호출하면 스레드가 `Runnable` 상태로 전이된다.
2. **Runnable → Blocked/Waiting/Timed Waiting**: 스레드가 락을 얻지 못하거나, `wait()` 또는
`sleep()` 메서드를 호출할 때 해당 상태로 전이된다.
3. **Blocked/Waiting/Timed Waiting → Runnable**: 스레드가 락을 얻거나, 기다림이 완료되면 다시
`Runnable` 상태로 돌아간다.
4. **Runnable → Terminated**: 스레드의 `run()` 메서드가 완료되면 스레드는 `Terminated` 상태가 된다.
