## 🤔 문제 상황
사내에서 개발중인 코드 중 어떠한 행위(A)가 일어났을 때 메일을 저장 및 전송해주는 로직을 짜고 있었다.
그래서 메인 로직인 A 함수의 마지막에 **비동기** 이벤트로 메일을 발송해주는 로직을 추가해주었는데, 오류가 났다. 
## 🕊️ 나의 생각
오류를 마주하자 말자 **비동기** <-> **트랜잭션** 사이에서의 문제라고 생각이 들었다.
비동기로 처리할 경우 새로운 새로운 스레드를 열어서 일관성이 맞지 않는 것인가?
## 🪄 실제 원인
`TransactionSynchronizationManager`라는 곳에서 트랜잭션의 정보를 `ThreadLocal`로 관리하는데, 이때 동일 스레드 내에서 트랜잭션의 동기화를 도와주는 트랜잭션 동기화 매니저이다.
<img width="959" alt="image" src="https://github.com/user-attachments/assets/e19f2618-ab58-4a86-86a0-9cada5eb7ad8">
즉 로직을 비동기로 처리하게 되면 새로운 스레드에서 트랜잭션이 열리고 실행하게 된다. 
`TransactionSynchronizationManager`는 **각각의 스레드마다 독립적**으로 커넥션을 관리하기 때문에 다른 스레드에서 실행 중인 트랜잭션의 정보는 알 수 없다. 
더 풀어서 쉽게 말하면 `스레드가 다르면, 같은 트랜잭션은 사용 불가능하다.`
## 💫 해결 방법
- `flush` 강제 호출!
- 트랜잭션 전파 레벨 : `REQUIRES_NEW`로 선언
  - 트랜잭션을 새롭게 만듬으로써 하나의 트랜잭션으로 묶이지 않도록 해준다.
## 나아가서
메일 전송이나 FTP 파일 전송 작업 혹은 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 무조건! 어떻게 해서든!.. **DBMS의 트랜잭션 내에서 제거**하는 것이 좋다고 한다.
프로그램이 실행되는 동안 외부 서버와 통신할 수 없는 상황이 발생한다면 WAS뿐 아니라 DBMS 서버까지도 위험해진다. exception이 발생하면 차라리 다행일 수도 있다.

---

### 참조
- https://codeinlife.tistory.com/73
- https://bimmm.tistory.com/51
- https://leezzangmin.tistory.com/25
