# 03. 코드의 구린내

### 중복코드
### 장황한 메서드
### 방대한 클레스
### 과도한 매개변수
### 수정의 산발
### 기능의 산재
### 잘못된 소속
### 데이터 뭉치
### 강박적 기본 타입 사용
### switch문
### 평행 상속 계층
### 직무유기 클래스
### 막연한 범용 코드
### 임시 필드
### 메시지 체인
### 과잉 중개 메서드
### 지나친 관여
### 인터페이스가 다른 대용 클래스
### 미흡한 라이브러리 클래스
### 데이터 클래스
### 방치된 상속물
### 불필요한 주석

---
- [책의 리팩토링 용어들 참조](https://refactoring.com/catalog/)

# 리팩토링 방법

### Extract Method
``` java
void printOwing(double amount)
{
  printBanner();
  //상세 정보 표시
  System.out.println( "name:" + _name );
  System.out.println( "amount:" + amount );
}

===========================================

void printOwing(double amount)
{
  printBanner();
  printDetails(amount);
}
void printDetails(double amount)
{
  System.out.println( "name:" + _name );
  System.out.println( "amount:" + amount );
}
```

동기 <br>
1. 메서드가 잘 쪼개져 있을 때 다른 메서드에서 사용될 확률이 높아진다.
2. 고수준(high-level)의 메서드를 볼 때 일련의 주석을 읽는 것 같은 느낌을 들도록 할 수 있다.

<details>
<summary>절차</summary>
<div markdown="1">

- 메서드를 새로 만들고 의도를 잘 나타낼 수 있도록 이름을 정한다.
  - `어떻게 하는지`가 아닌 `무엇을 하는지`를 나타내게 이름을 정한다.
  - 뽑아내고자 하는 부분이 한 줄의 메시지나 함수 호출과 같이 아주 간단한 경우에는 새로운 메서드의 이름이 그 코드의 의도를 더 잘타나낼 수 있을 때만 뽑아낸다.
  - 더 이해하기 쉬운 이름을 지을 수 없다면 코드를 뽑아내지 않는 것이 낫다.
- 원래 메서드에서 뽑아내고자 하는 부분의 코드를 복사하여 새 메서드로 옮긴다.
- 원래 메서드에서 사용되고 있는 지역변수가 뽑아낸 코드에 있는지 확인한다. 이런 지역변수는 새로운 메서드의 지역변수나 파라미터가 된다.
- 뽑아낸 코드 내에서만 사용되는 임시변수가 있는지 본다. 있다면 새로운 메서드의 임시변수를 선언한다.
- 뽑아낸 코드 내에서 지역변수의 값이 수정되는지 본다. 하나의 지역변수만 수정 된다면, 뽑아낸 코드를 질의(query)로 보고 수정된 결과를 관련된 변수에 대입 할 수 있는지 본다.
  - 이렇게 하는것이 이상하거나 값이 수정되는 지역변수가 두개 이상 있다면 쉽게 메서드로 추출할 수 없는 경우이다.
  - 이럴때는 `Split Temporary Variable`을 사용한 다음 다시 시도해보자. 임시변수는 `Replace Temp with Query`로 제거할 수 있다.
- 뽑아낸 코드에서 읽기만 하는 변수는 새 메소드의 파라미터로 넘긴다
- 지역변수와 관련된 사항을 다룬 후에는 컴파일을 한다.
- 원래 메소드에서 뽑아낸 코드 부분은 새로 만든 메소드를 호출하도록 바꾼다.
  - 새로 만든 메소드로 옮긴 임시변수가 있는 경우 그 임시변수가 원래 메소드의 밖에서 선언되었는 지를 확인한다. 만약 그렇다면 새로 만들 메소드에서는 선언을 해줄 필요가 없다.
- 컴파일과 테스트를 한다.

</div>
</details>
