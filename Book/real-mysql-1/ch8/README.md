# 8. 인덱스

## 8.1 디스크읽기방식

인덱스에 들어가기 앞 `랜덤I/O`와 `순차(시퀀셜)I/O`에 대해 알아보는게 좋다. (추후..)<br>
또한 DB나 쿼리 튜닝은 어떤 디스크의 I/O를 줄이느냐가 관건일 때가 많다.

### HDD와 SSD

> 컴퓨터에서 CPU나 메모리 같은 주요 장치는 대부분 전자식 장치지만, 하드 디스크 드라이브 (HDD)와 같은 보조 기억 장치는 기계식 장치이다.<br>
> 그래서 DB 서버에서는 항상 디스크 장치가 병목이 된다.<br>
> 이러한 병목을 해결하기 위해서 기계식 HDD를 대체하여 전자식 저장 매체인 SSD를 사용하기도 한다.<br>

#### SSD의 특정

- 기존 HDD에서 데이터 저장용 플래터를 제거하고 그 대신 **플래시 메모리**를 장착하고 있다.
    - 그래서 디스크 원판을 기계적으로 회전시킬 필요가 없으므로 아주 빨리 데이터를 읽고 쓸 수 있다.
- 플래시 메모리는 전원이 공급되지 않아도 데이터가 삭제되지 않는다.
- 컴퓨터 메모리 (D-Ram)보다는 느리지만 기계식 HDD보다는 훨씬 빠르다.
  ![img.png](img.png)

디스크의 헤더를 움직이지 않고 한 번에 많은 데이터를 읽는 순차 I/O에서는 SSD가 HDD 보다 조금 빠르거나 엇비슷한 성능을 보이기도 한다.<br>
하지만 SSD의 장점은 기존 HDD보다 **랜덤I/O 성능이 월등히 뛰어나다는 것**이다.<br>
DB 서버에서 순차I/O 작업은 그다지 비중이 크지 않고, 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로 SSD의 장점은 DBMS용 스토리지에 최적이라고 볼 수 있다.

### 랜덤I/O & 순차I/O

> 랜덤 I/O라는 표현은 하드 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다.
> 사실 순차I/O 또한 이 작업 과정은 같다. 그렇다면 이 둘은 어떤 차이가 있을까?

![img_1.png](img_1.png)
> 순차 I/O는 3개의 페이지(3 X 16KB)를 디스크에 기록하기 위해 한 번 시스템 콜을 요청했지만, 랜덤I/O는 3개의 페이지를 디스크에 기록하기 위해 세 번 시스템 콜을 요청함.

- 디스크에 데이터를 읽고 쓰는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.
    - 결국 위 그림의 경우 순차I/O가 랜덤 I/O보다 3배 빠르다고 할 수 있다.
- 즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정 된다고 볼 수 있다.
- 그래서 **여러 번 쓰기 또는 읽기를 요청하는 랜덤 I/O 작업이 작업 부하가 훨씬 더 크다.**
- DB 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에는 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장돼 있다.
- 또한 SSD 드라이브에서도 랜덤 I/O는 여전히 순차I/O보다 전체 스로풋이 떨어진다.

사실 쿼리를 튜닝해서 랜덤I/O를 순차I/O로 바꿔서 실행할 방법은 그다지 많지 않다.<br>
일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.

> ### 참고
> - 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤I/O를 사용한다.
> - 풀 테이블 스캔은 순차 I/O를 사용한다.
>
> 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.<br>
> 이는 순차 I/O가 랜덤 I/O보다 훨씬 빨리 많은 레코드를 읽어올 수 있기 때문인데, 이런 형태는 OLTP(OnLine Transaction Processing) 성격의 웹 서비스보다는 데이터
> 웨어하우스나 통계 작업에서 자주 사용된다.

## 8.2 인덱스

> DB 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다.<br>
> 그래서 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의(key-value) 쌍으로 삼아 인덱스를 만들어 두는 것이다.
> 이 때 해당 데이터로 더욱 빠르게 찾아가기 위해 컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

#### 자료구조와 비교해보자.
- `SortedList`는 DBMS의 인덱스와 같은 구조이다.
  - 저장되는 값을 항상 정렬된 상태로 유지하는 자료구조이다.
  - 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬되어 있어 아주 빨리 원하는 값을 가져올 수 있다.
- `ArrayList`는 데이터 파일과 같은 자료구조를 사용한다.
  - 값을 저장되는 순서 그대로 유지하는 자료 구조다.

결론적으로 DBMS에서 **인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.**<br>
`SELECT` 쿼리 문장의 `WHERE` 조건절에 사용되는 컬럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있다.
