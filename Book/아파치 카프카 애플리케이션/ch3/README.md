# 3. 카프카 기본 개념 설명

## 3.1 카프카 브로커, 클로스터 주키퍼
## 카프카 브로커
- 하나의 서버에는 한 개의 카프카 브로커가 실행된다.
- **3대 이상을 묶어서 클러스터**로 운영한다.
- 데이터를 전달받아 토픽의 파티션에 데이터를 저장하고, 전달한다.
- 데이터는 **파일 시스템**에 저장된다.
> 카프카는 데이터를 메모리나 데이터베이스가 아니라 파일에 저장하는데, `파일 시스템에 저장하면 파일 입출력으로 인해 느리지 않을까?`
> - 카프카는 페이지 캐시(page cache)를 사용해 디스크 입출력 속도를 높였다.
> - 한 번 읽은 파일의 내용은 메모리의 페이지 캐시 영역에 저장된다.
> - JVM 상에서 동작하는 카프카가 직접 캐시를 구현하는 게 아니다. (그랬더라면 gc가 자주 일어났을 것이다.)
>   - 그래서 카프카 힙 사이즈를 크게 설정하지 않아도 된다.
### 데이터 복제, 싱크
장애 발생시에도 데이터를 유실하지 않고 안전하게 사용하기 위해서 데이터 복제(싱크)를 진행한다.<br>
카프카의 데이터 복제는 **파티션 단위**로 이루어지며 복제된 파티션은 `리더` & `팔로워`로 구성된다.<br>
- 팔로워의 파티션은 리더 파티션으로부터 데이터를 가져와서 자신의 파티션에 저장한다.
- 복제 개수만큼 저장 용량이 증가한다는 단점을 가지고 있다.
- 리더 파티션에 장애가 발생하면 다른 팔로워 파티션이 그 기능을 위임 받는다.

### 컨트롤러
클러스터의 다수 브로커 중 한 대가 컨트롤러의 역할을 한다.<br>
- 컨트롤러는 다른 브로커들의 상태를 체크한다.
- 브로커가 클러스터에서 빠지는 경우 해당 브로커에 존재하는 **리더 파티션을 재분배한다**.

### 데이터 삭제
카프카는 다른 메시징 플랫폼과 다르게 컨슈머가 데이터를 가져가더라도 토픽의 데이터는 삭제되지 않는다.<br>
컨슈머나 프로듀서가 데이터 삭제를 요청할 수도 없다. **오직 브로커만이 데이터를 삭제할 수 있다.**
- 데이터 삭제는 파일 단위로 이루어지는데 이 단위를 `로그 세그먼트`라고 부른다.
  - 이 세그먼트에는 다수의 데이터가 들어있기 때문에 일반적인 데이터베이스처럼 특정 데이터를 선별해서 삭제할 수 없다.
- 닫힌 세그먼트 파일은 `log.retention.bytes` 또는 `log.retention.ms` 옵션에 설정값이 넘으면 삭제된다.
- 카프카는 데이터를 삭제하지 않고 메시지 키를 기준으로 오래된 데이터를 압축하는 정책(토픽 압축 정책)을 가져갈 수 있다.

### 코디네이터
코디네이터는 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배하는 역할을 한다.
- 브로커 중 하나가 코디네이터 역할을 수행한다.
- 파티션을 컨슈머로 재할당하는 과정을 수행한다.
  - 즉 **리밸런스**를 수행한다.

---
