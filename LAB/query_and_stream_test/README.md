# 🦄 `findByXXX()` VS `findAll() + stream(filter)`

`findAll()`로 DB에서 데이터를 모두 조회한 후 `stream(filter)`로 조회 하는 것과 조건에 맞는 데이터를 DB에서 한번에 가져오는 `findByXXX()`중 어떤 것이 성능에 이점이 있을까?

| 조회 방식                                           | 100건  | 1,000건 | 10,000건 | 100,000건 |
|-------------------------------------------------|-------|--------|---------|----------|
| findAll()                                       | 8ms   | 9ms    | 37ms    | 237ms    |
| findAllByNameIn()                               | 6.4ms | 5.45ms | 17ms    | **44ms**     |
| findAll() + stream filter (by names)            | 9ms   | 7ms    | 49ms    | **256ms**    |
| findAllByEmail() [100건만 타겟]                     | 8ms   | 10ms   | 12ms    | **28ms**     |
| findAll() + stream filter (by email) [100건만 타겟] | 9ms   | 11ms   | 41ms    | **260ms**    |

## 🪄 성능 차이 분석
### 1. 데이터 처리 위치
- DB 레벨 필터링 (findByXXX)
  - WHERE 절이나 IN 절을 통한 DB 단계 필터링
  - DB 인덱스를 활용한 빠른 검색
  - 필터링된 결과만 네트워크 전송
- 애플리케이션 레벨 필터링 (findAll + stream)
  - 전체 데이터를 애플리케이션으로 로드
  - 애플리케이션 메모리에서 필터링
  - 불필요한 데이터까지 네트워크 전송
### 2. 리소스 사용량 비교
- DB 레벨 필터링
  - 필요한 데이터만 메모리 적재
  - 최소한의 네트워크 사용
  - DB 최적화 엔진 활용
- 애플리케이션 레벨 필터링
  - 전체 데이터 메모리 적재
  - 전체 데이터 네트워크 전송
  - 애플리케이션 CPU 자원 사용
### 3. 연산 복잡도
- DB 레벨
  - `findAllByNameIn()`: O(log n) * 검색 조건 수
  - `findAllByEmail()`: O(log n) (인덱스 사용 시)
- 애플리케이션 레벨
  - 전체 데이터 조회: O(n)
  - 스트림 필터링: O(n) * 검색 조건 수

## 🎯 결론 및 권장사항
### 데이터 규모별 특징
- 소규모 데이터 (1만건 이하)
  - 두 방식의 성능 차이가 미미
  - 구현 편의성 기준으로 선택 가능
- 대규모 데이터 (10만건 이상)
  - DB 레벨 필터링이 압도적으로 유리
  - 리소스 사용량 차이가 명확

### 권장사항
1. 가능한 DB 레벨에서 필터링 (findByXXX 사용)
   1. DB는 이러한 쿼리에 대해 최적화가 잘 되어있음
   2. 특히 name 컬럼에 인덱스가 있다면 더욱 효율적
   3. 병렬 처리나 쿼리 최적화 등 DB 엔진의 장점을 활용할 수도 있다.
2. 필요한 데이터만 조회 (불필요한 컬럼 제외)
3. 대용량 데이터의 경우 페이징 처리 필수
4. 복잡한 비즈니스 로직의 경우만 선별적으로 스트림 필터링 사용
