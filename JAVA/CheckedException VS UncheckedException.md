# 자바 예외의 이해

### Object :예외도 객체이다

-   모든 객체의 최상위 부모는 Object 이므로 예외의 최상위 부모도 Object 이다.

### Throwable : 최상위 예외이다.

-   하위에 Exception 과 Error 가 있다.

### Error :메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구 불가능한 시스템 예외이다. 애플리케이션 개발자는 이 예외를 잡으려고 해서는 안된다.

-   상위 예외를 catch 로 잡으면 그 하위 예외까지 함께 잡는다. 따라서 애플리케이션 로직에서는 Throwable 예외도 잡으면 안되는데, 앞서 이야기한 Error 예외도 함께 잡을 수 있기 때문이다. 애플리케이션 로직은 이런 이유로 Exception 부터 필요한 예외로 생각하고 잡으면 된다. 참고로 Error 도 언체크 예외이다.

### Exception : 체크 예외

-   애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외이다.
-   Exception 과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외이다. 단 RuntimeException 은 예외로 한다.
-   ex) 존재하지 않는 파일의 이름 입력(FileNotFoundException) , 실수로 클래스 이름 오타(ClassNotException)

### RuntimeException : 언체크 예외, 런타임 예외

-   컴파일러가 체크 하지 않는 언체크 예외이다.
-   RuntimeException 과 그 자식 예외는 모두 언체크 예외이다.
-   RuntimeException 의 이름을 따라서 RuntimeException 과 그 하위 언체크 예외를 런타임 예외라고 많이 부른다. 
- ex) 배열의 범위를 벗어난(ArrayIndexOutOfBoundsException)
값이 null이 참조변수를 참조(NullPointerException)
---

### 체크/언체크 예외의 RollBack 시기 
| 구분          | Checked Exception | Unchecked Exception |
|-------------|-------------------|---------------------|
| 발생 시점       | 컴파일 시점            | 프로그램 실행시            |
| 처리 유무       | 예외 처리 필수          | 예외처리가 강제되지 않음       |
| 예외시 트랜잭션 처리 | Rollback X        | Rollback O          |


### 체크 예외의 장단점

-   체크예외는 예외를 잡아서 처리할 수 없을 때,예외를 밖으로 던지는 throws 예외를 필수로 선언해야 한다. 그렇지 않으면 컴파일 오류가 발생한다.
-   이것 때문에 장점과 단점이 동시에 존재한다.  
    \- **장점**: 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아주는 훌륭한 안전 장치이다.  
    \- **단점**: 하지만 실제로는 개발자가 모든 체크 예외를 반드시 잡거나 던지도록 처리해야 하기 때문에, 너무 번거로운 일이 된다.  
    \- 크게 신경쓰고 싶지 않은 예외까지 모두 챙겨야 한다.  
    \- 추가로 의존관계에 따른 단점도 있다

### 언체크 예외의 장단점

-   언체크 예외는 예외를 잡아서 처리할 수 없을 때,예외를 밖으로 던지는 throws 예외를 생략할 수 있다.
-   이것 때문에 장점과 단점이 동시에 존재한다.  
    \- **장점**: 신경쓰고 싶지 않은 언체크 예외를 무시할 수 있다.  
    \- 체크 예외의 경우 처리할 수 없는 예외를 밖으로 던지려면 항상 throws 예외 를 선언해야 하지만, 언체크 예외는 이 부분을 생략할 수 있다.  
    \- 신경쓰고 싶지 않은 예외의 의존관계를 참조하지 않아도 되는 장점이 있다.  
    \- **단점**: 언체크 예외는 개발자가 실수로 예외를 누락할 수 있다. 반면에 체크 예외는 컴파일러를 통해 예외 누락을 잡아준다.

### 예외처리가 성능에 큰 영향을 미칠까?
- 예외발생 시 예외 객체를 만들고 예외 내에 메시지를 포함한 내용을 넣어야 하므로 성능 소요가 크다. 
- 따라서 단순 반환 등의 이유로 예외를 생성해서 `throw` 하지 않는 것이 권장된다
### 만약 그렇다면, 어떻게 하면 부하를 줄일까?
- 예외가 발생했을 경우 디버깅용 로그를 남기기로 했다면, 정말 **필요한 정보만 가독성 있게 로그를 남긴다**
- 한줄의 로그라도 디버깅 하기 쉽도록 작성하면 유지보수면에서 효율성+로깅 시스템에 부하도 줄일 수 있다

### 예외처리시 주의 사항
1.  catch에는 로깅, 복구 등의 로직을 추가하기
     - 예외를 아무 로직 없이 throw/catch만 하지 않는다
     - 로그를 출력해 주거나, 원상 복구 가능한 로직을 첨가하는 등 catch만 수행 하지 않고 해당 예외에 대한 처리를 해준다
2. 예외 Stack을 남겨 추적, 유지보수성 높이기
   - 예외의 유지보수성을 높이기 위해, `e.toString()`,`e.getMessage()`로 마지막 예외 메세지만 남기기보다,전체 예외 스택을 다 넘기는게 좋다
3. Logging Framework 사용하기
   - Logging Framework를 이용하면 로그 파일을 쪼갤 수 있고, 여러 서버의 log를 한곳에서 모아서 보는 System을 활용할 수도 있다 

> ### 체크 예외 VS 언체크 예외
> 
> -   체크 예외 : 예외를 잡아서 처리하지 않으면 항상 throws 에 던지는 예외를 선언해야 한다.
> -   언체크 예외: 예외를 잡아서 처리하지 않아도 throws 를 생략할 수 있다.