# 불변 객체 (Immutable Object)란

> - 객체지향 프로그래밍에 있어, **생성 후 그 상태를 바꿀 수 없는 객체**를 말한다
> - 경우에 따라서 내부에서 사용하는 속성이 변화해도 외부에서 그 객체의 상태가 변하지 않은 것처럼 보인다면 불변 객체로 보기도 한다
> - 불변 객체를 사용하면 **복제나 비교를 위한 조작을 단순화 할 수 있고, 성능 개선**에도 도움을 준다
> - but 객체가 변경 가능한 데이터를 많이 가지고 있는 경우, 불변이 오히려 부적절한 경우가 있다

**즉. 불변객체는 재할당은 가능하지만, 한번 할당하면 내부 데이터를 변경할 수 없는 객체**
- 대표적인 예 : String, Integer,Boolean등
### String?
보통, String을 선언할 때 아래처럼 선언한다
```java
String str = "ab";
```
만약 문자열을 더 추가하게 된다면?
```java
String str = "ab";
str = str + "cd";
```
`str`이 변경 됐다 생각할 수 있지만, 실제로 "ab"라는 String 객체는 그대로 남아있고,"abcd"라는 새로운 객체가 `str`변수에 할당된다 
> Java에서 String은 특이하게도 **Heap영역**에 **String Constant Pool**이 존재하는데, String을 **Literal**(ex: `String a="apple"`)로 생성하면 이 영역에 저장되어 **재사용 된다**</br>
> 하지만 `new` 생성자로 생성하면 **Constant Pool**을 사용하지 않고, 일반적인 **Heap영역**에 생성하여 **재사용하지 않게 된다**

### 불변객체의 장단점
- 장점
  - 객체에 대한 신뢰도가 높아진다. 객체가 한번 생성되고 변하지 않는다면 트랜잭션내에서 우리가 믿고 쓸 수 있기 때문이다
  - 생성자,접근메서드에 대한 방어 복사가 필요없다
  - 멀티스레드 환경에서 동기화 처리없이 객체를 공유할 수 있다(공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문) = Thread-safe하다
  - 가비지 컬렉션(GC) 성능을 높일 수 있다 = 가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 Gc 수행 시 지연시간도 줄어든다

(가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 Gc 수행 시 지연시간도 줄어든다.)
- 단점
  - 생성할 때 초기값이 아닌, 새로운 값을 입력하려면 새 객체를 만들어야 한다 -> 그 만큼 자원의 소모가 많아지며,코드 재사용성이 떨어진다

### 불변객체와 final
- final의 사전상 의미는 '마지막','최종'의 의미가 있다
- final 키워드는 크게 **변수,메서드,클래스**에서 사용이 가능하다
- **변수**에서의 final:
  - 더이상 **재할당**할 수 없다
  - 초기화 방법: 1. 클래스의 필드에 선언 2. 생성자에서 초기화
- **메서드**에서의 final:
  - 해당 메서드는 **오버라이딩(메서드 재정의)** 될 수 없다 
- **클래스**에서의 final:
  - 해당 클래스는 **상속**할 수 없다. 즉 부모 클래스가 될수 없다
- Java에서는 필드가 원시 타입(primitive type)인 경우 final 키워드를 사용해 불변 객체를 만들 수 있고, 참조 타입(reference type)일 경우 *`추가적인 작업`이 필요하다
  - **참조 타입**은 대표적으로 1.객체를 참조할 수도 있고, 2.배열이나 3.List 등을 참조할 수 있다
    - 1.참조 변수가 일반 객체인 경우 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경해야 한다
    - 2.배열일 경우 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하도록 하면 된다 (배열을 그대로 참조하거나, 반환할 경우 외부에서 내부 값을 변경할 수 있음. 때문에 clone을 반환해 외부에서 값 변경하지 못하게 함)
    - 3.리스트인 경우에도 배열과 마찬가지로 생성시 새로운 List를 만들어 값을 복사하도록 해야 합니다.

배열과 리스트는 내부를 복사하여 전달하는데, 이를 방어적 복사(defensive-copy)라고 합니다.
  
> 그렇다면 `final`이 불변을 의미할까?
>- 정답은 완벽한 불변성을 의미하지는 않는다. final은 해당 변수의 **재할당만 막아줄 뿐**, 참조하고 있는 객체 내부의 상태가 변하지 않았음을 보장해주지는 않는다 

### 불변객체를 만드는 방법
1. 객체의 상태를 변경할 수 있는 메서드를 제공하지 않는다 (ex. setter)
2. 모든 필드를 final과 private를 사용해서 선언한다
3. **클래스를 final로 선언**하여 하위클래스에서의 오버라이딩을 막아라
4. 객체를 생성하기 위한 **생성자** or **정적 팩토리 메서드**를 추가해라
5. 참조에 의해 값의 변경이 있는 경우, **방어적 복사**를 이용하여 전달해라



