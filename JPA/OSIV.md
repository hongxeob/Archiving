## OSIV

- Open-Session-In-View의 줄임말이다.
- JPA에서는 OEIV, 하이버네이트에서는 OSIV라고 부르지만 같은 기능이다.
- OSIV 전략은 트랜잭션 시작시 최초 DB 커넥션 시작 시점부터 API응답이 끝날 때(View)까지 영속성 컨텍스트와 DB 커넥션을 유지한다.
- 즉 View 레이어에서도 지연로딩을 사용할 수 있다.

## 특징
- 클라이언트 요청이 들어올 때 영속성 컨텍스트를 생성해서 요청이 끝날 때까지 같은 영속성 컨텍스트를 유지한다.
    - 그래서 한 번 조회된 엔티티는 요청이 끝날 때까지 영속 상태를 유지한다.
- 엔티티 수정은 트랜잭션이 있는 계층에서만 동작한다.
    - 트랜잭션이 없는 프레젠테이션 계층은 지연 로딩을 포함해 조회만 할 수 있다.

## 동작원리
스프링이 제공하는 OSIV 클래스는 서블릿 필터에서 적용할지 스프링 인터셉터에서 적용할지에 따라 원하는 클래스를 선택해서 사용하면 된다.
>스프링 프레임워크가 제공하는 OSIV는 **비즈니스 계층에서 트랜잭션을 사용하는 OSIV**다.<br>
영속성 컨텍스트는 사용자의 요청 시점에서 생성이 되지만, 데이터를 쓰거나 수정할 수 있는 트랜잭션은 비즈니스 계층에서만 사용할 수 있도록 트랜잭션일 일어난다.

동작원리는 다음과 같다.

1. 클라이언트의 요청이 들어오면 서블릿 필터나, 스프링 인터셉터에서 **영속성 컨텍스트를 생성**한다. 단 이 시점에서 트랜잭션 시작 X
2. 서비스 계층에서 @Transactional로 트랜잭션을 시작할 때 1번에서 **미리 생성해둔 영속성 컨텍스트를 찾아와서** 트랜잭션을 시작한다.
3. 서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 이 시점에서 트랜잭션은 끝내지만 영속성 컨텍스트는 종료되지 않는다.
4. 컨트롤러와 뷰 까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 유지한다.
5. 서블릿 필터나, 스프링 인터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료한다. 이때 플러시를 호출하지 않고 바로 종료한다.

## 장점

- 지연로딩 사용이 편리하다.
- 즉 유지보수성이 높아진다.
- 즉 성능 빼고는 거의 장점 뿐이다.

## 단점

- 영속성 컨텍스트와 DB 커넥션은 1:1로 물고있는 관계이기 때문에 프레젠테이션 로직까지 DB 커넥션 자원을 낭비하게 됨.
- OSIV를 적용하면 같은 영속성 컨텍스트를 여러 트랜잭션이 공유하게될 수도 있다.
- 프레젠테이션에서 엔티티를 수정하고 비즈니스 로직을 수행하면 엔티티가 수정될 수 있다.
- 프레젠테이션 계층에서 렌더링 과정에서 지연 로딩에 의해 SQL이 실행된다. 따라서 성능 튜닝시에 확인해야 할 부분이 넓어진다.

## OSIV를 사용할까 말까?

- 간단한 서비스라면 OSIV의 생산성 증대가 도움이 될 수 있다.
- 하지만 조금이라도 서비스가 복잡해지면 OSIV로 인한 문제들이 발생할 수 있다.
    - 특히 외부 호출이 잦거나 트랜잭션 밖에서 로직이 많은 경우 OSIV를 **비활성화하는 것이 매우 추천**된다.

## 추천 전략

- 커맨드와 쿼리 분리
    - 실무에서 OSIV를 끈 상태로 복잡성을 관리하는 좋은 방법은 커맨드와 쿼리를 분리하는 것이다.