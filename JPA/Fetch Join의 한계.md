# 페치조인의 한계

### 1. 별칭, Where절 사용 금지

- 페치 조인의 역할 또는 정의를 위배하기 때문이다.
    - 페치 조인은 Entity를 모두 조회한다는 정의를 가지고 있는데, Where절을 통해 필터링을 하면 페치 조인의 결과값에 변화를 주게 된다.
    - 즉 연관된 Entity를 모두 조회한다는 역할이 필터링을 사용함으로써 변질되는 것이다.

### 2. 둘 이상의 컬렉션은 페치조인 할 수 없다.

- 두 컬렉션의 페치 조인은 컬렉션 X 컬렉션의 결과를 만든다.
- 즉 카테시안 곱의 결과를 만들어낸다. (조회 데이터가 엄청나게 증가)

### 3. OneToMany fetch join 페이징 쿼리 성능 이슈

- 일대일(OneToOne), 다대일(ManyToOne)처럼 단일 값 연관 필드의 경우 페치 조인과 페이징을 사용할 수 있다.
    - 이유는 데이터가 컬렉션 페치 조인과 다르게 데이터가 증가하지 않기 때문이다.
    - 즉 조회된 데이터의 수를 예상할 수 있다.
- **그러나 컬렉션 페치 조인, 즉 일대다(OneToMany)의 경우 페이징이 불가능 하다.**
    - 그 이유는 컬렉션 데이터의 수를 가늠하기가 어렵다.
    - 그러므로 잘못된 페이지 사이즈 설정이 데이터 누락을 초래하게 된다.

## `MultipleBagFetchException`?

- 2개 이상의 OneToMany 자식 테이블에 페치 조인을 선언 했을 때 생기는 에러
- 1:N 관계의 자식 테이블 여러곳에 페치 조인을 사용하면 생기는 에러
- JPA에서 페치 조인의 조건은 ToOne은 몇개든 사용 가능, ToMany는 1개만 가능

### 해결책 : BatchSize

- N+1 문제는 결국 부모 엔티티와 연관 관계가 있는 자식 엔티티들의 조회 쿼리가 문제다.
- 1개씩 사용되는 조건문을 in절로 묶어서 조회 한다면 ? → 이 기능이 `hibernate.default_batch_fetch_size`
- 해당 옵션은 **지정된 수만큼 in절에 부모 Key를 사용**하게 해준다.
- 즉 100개를 옵션값으로 지정하면 100개 단위로 in절에 부모 Key가 넘어가서 자식 엔티티들이 조회되는 것이다.
>만약 **1만개의 Store** (부모 엔티티)가 조회된다면
> - 옵션 미적용시
>   - 총 **20,001번**의 쿼리가 수행
>   - Store 조회 쿼리 1번
>   - 각 Store의 Product 조회 쿼리가 10,000번
>   - 각 Store의 Employeee 조회 쿼리가 10,000번
> - 옵션 적용시 (1000개)
>   -총 **21번**의 쿼리가 수행
>   - Store 조회 쿼리 1번
>   - 각 Store의 Product 조회 쿼리가 10번 (10,000 / 1,000)
>   - 각 Store의 Employee 조회 쿼리가 10번 (10,000 / 1,000)
- Tip)같은 방법으로 **Fetch 적용시 발생하는 페이징 문제도 동일하게 해결된다.**
    - 1:N 관계에서의 페이징 문제는 Join으로 인해 1에 대한 페이징이 정상작동 하지 않기 때문이다.