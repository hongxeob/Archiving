## OneToOne 양방향 관계 Lazy 로딩

>JPA 구현체인 Hibernate에서는 `@OneToOne` 양방향 매핑 시 지연 로딩(Lazy)으로 설정해도 지연 로딩이 동작하지 않고, 즉시 로딩(EAGER)이 동작하는 이슈가 있다.

- 테이블을 조회할 때, 외래키를 가지고 있는 테이블(연관 관계 주인)에서는 외래키를 가지지 않은 쪽에 대한 지연로딩은 동작한다.
    - 하지만 `mappedBy` 속성으로 연결된 외래키를 가지지 않은 쪽에서 테이블을 조회할 경우 외래키를 가지고 있는 테이블(연관 관계 주인)에 대해서는 지연 로딩이 동작하지 않고 N+1 쿼리가 발생하게 되는 것이다.

## 문제의 원인

우선 지연 로딩이 동작하는 매커니즘을 이해해야 한다.

- 지연 로딩은 로딩되는 시점에 Fetch 전략이 Lazy로 설정되어 있는 엔티티를 프록시 객체로 가져 온다.
    - ex) User, UserInfo가 엔티티가 있다고 치면, User를 조회할 때 UserInfo를 프록시 객체로 가져오게 된다.
- 이후 실제로 UserInfo객체를 사용하는 시점에 초기화 되면서 쿼리가 실행된다.
    - ex) `getUserInfo()`처럼 UserInfo객체가 사용되었을 때 쿼리가 실행되는 것이다.

이렇게 지연 로딩으로 설정이 되어있는 엔티티를 조회할 때는 프록시로 감싸서 동작하게 되는데, 프록시는 null을 감쌀 수 없기 때문에 이와 같은 문제점이 발생하게 된다.<br>
즉 프록시의 한계로 인해 발생하는 문제이다.    
## OneToOne 관계에서 Lazy 로딩을 사용하기 위한 조건들

>`@OneToOne`으로 매핑 관계를 설정시 기본적으로 EAGER 로딩을 한다.<br>
그 이유는 null 값이 가능한 OneToOne child를 Proxy화 할 수 없기 때문이다.

`@OneToOne`에서 LAZY로딩을 하고자 하기 위해 3가지 조건을 충족시켜야 한다.
- 서로가 무조건 존재해야한다. OneToOne 관계의 옵션 중 `optional=false`가 만족해야한다.
- 양방향 관계가 아닌 단방향 관계이어야 하며, 부모 테이블이 자식의 PK를 FK로 가지는 형태로 연관 관계의 주인이 되어야 한다.
- `@PrimaryKeyJoin`은 허용되지 않는다.
## DB 구조?

DB로 생각하면, 먼저 insert될 정보가 main, parent가 되어야지 되고, child는 나중에 insert가 되어야지 된다고 생각하기 쉽다.<br>
그렇지만, 이는 `@OneToMany`로 지정된 parent-child 구조에서 이렇게 되는 것이고, `@OneToOne`의 경우에는 child가 먼저 저장이 되어야지 되는 것을 명심하자. 이는 DB Table의 구조에 지대한 영향을 미치게 된다.

- `@OneToMany`의 경우, child에서 parent PK를 갖는 구조가 되어야지 된다.
    - parent가 먼저 저장이 되어야지 된다.
- `@OneToOne`의 경우, parent에서 child PK를 갖는 구조가 되어야지 된다.
    - child가 먼저 저장되어야지 된다.

## 해결 방법
1. 양방향 관계가 아닌 단방향으로 매핑한다.
2. Fetch Join을 사용해서 가져온다.
3. `@OneToOne`은 피할 수 있으면 최대한 피하라…