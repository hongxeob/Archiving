## N+1 문제란

한 번의 쿼리를 날렸을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것을 의미한다.

- 언제 발생 하는가?
    - JPA Repository를 활용해 인터페이스 메소드를 호출할 때(Read 시)
- 누가 발생시키는가?
    - 1:N or N:1 관계를 가진 엔티티를 조회할 때 발생
- 어떤 상황에 발생 되는가?
    - JPA Fetch 전략이 `EAGER 전략`으로 데이터를 조회하는 경우
    - JPA Fetch 전략이 `LAZY 전략`으로 데이터를 가져온 이후에 연관 관계인 하위 엔티티를 다시 조회 하는 경우
- 왜 발생 하는가?
    - JPA Repository로 find시 실행하는 첫 쿼리에서 하위 엔티티까지 한 번에 가져오지 않고, 하위 엔티티를 추가로 조회하기 때문에
    - JPQL은 기본적으로 글로벌 Fetch 전략을 무시하고 JPQL만 가지고 SQL을 생성하기 때문에

### EAGER(즉시 로딩)의 경우

1. JPQL에서 만든 SQL을 통해 데이터를 조회
2. 이후 JPA에서 Fetch 전략을 가지고 해당 데이터의 연관 관계인 하위 엔티티들을 추가로 바로 조회
3. 2번의 과정으로 N+1 문제 발생

### LAZY(지연 로딩)의 경우

1. JPQL에서 만든 SQL을 통해 데이터를 조회
2. JPA에서 Fetch전략을 가지지만, 지연 로딩이기 때문에 바로 추가 조회는 하지 않음
3. 하지만, 하위 엔티티를 가지고 추가 작업을 하게 되면 추가 조회가 발생 → N+1 문제 발생

## N+1 문제 해결 방법

해결 방법에는 많은 방법이 있다.

### 1. [페치조인 (Fetch Join)](https://github.com/hongxeob/TIL/blob/main/JPA/JPQL%20%ED%8E%98%EC%B9%98%EC%A1%B0%EC%9D%B8.md)

- JPQL을 사용하며 DB에서 데이터를 가져올 때 처음부터 연관된 데이터까지 함께 같이 가져오는 방법이다.
- 별도의 메소드를 만들어줘야 하며 `@Query` 어노테이션을 사용해서 `join fetch 엔티티.연관관계_엔티티` 구문을 만들어 주면 된다.
- 하지만 1:N 페치조인에서는 데이터 뻥튀기가 생긴다.
    - 반대인 N:1 경우에는 생기지 않는다.
    - 그래서 중복을 제거해주는 `DISTINCT`를 사용한다.

### 2. EntityGraph 어노테이션

- 말그대로 `@EntityGraph` 어노테이션을 사용하는 것 인데, 이런게 있다는 것만 알아두고 사용하지는 말자..
    - 사용하는 순간 조금만 관계가 복잡해져도 헬게이트 OPEN..